<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>Lambda</title><meta name=viewport content="width=device-width,minimum-scale=1"><meta name=description content="This blog is about Python, Golang, Django, IT, Architecture etc."><meta name=generator content="Hugo 0.105.0"><meta name=robots content="noindex, nofollow"><link rel=stylesheet href=/ananke/css/main.min.css><link href=/tags/index.xml rel=alternate type=application/rss+xml title=Lambda><link href=/tags/index.xml rel=feed type=application/rss+xml title=Lambda><meta property="og:title" content="Tags"><meta property="og:description" content="This blog is about Python, Golang, Django, IT, Architecture etc."><meta property="og:type" content="website"><meta property="og:url" content="/tags/"><meta itemprop=name content="Tags"><meta itemprop=description content="This blog is about Python, Golang, Django, IT, Architecture etc."><meta name=twitter:card content="summary"><meta name=twitter:title content="Tags"><meta name=twitter:description content="This blog is about Python, Golang, Django, IT, Architecture etc."></head><body class="ma0 avenir bg-near-white"><header><div class="pb3-m pb6-l bg-black"><nav class="pv3 ph3 ph4-ns" role=navigation><div class="flex-l justify-between items-center center"><a href=/ class="f3 fw2 hover-white no-underline white-90 dib">Lambda</a><div class="flex-l items-center"><ul class="pl0 mr3"><li class="list f5 f4-ns fw4 dib pr3"><a class="hover-white no-underline white-90" href=/ title="Home page">Home</a></li><li class="list f5 f4-ns fw4 dib pr3"><a class="hover-white no-underline white-90" href=/blog/ title="Blog page">Blog</a></li><li class="list f5 f4-ns fw4 dib pr3"><a class="hover-white no-underline white-90" href=/categories/ title="Categories page">Categories</a></li></ul><div class=ananke-socials></div></div></div></nav><div class="tc-l pv3 ph3 ph4-ns"><h1 class="f2 f-subheadline-l fw2 light-silver mb0 lh-title">Tags</h1></div></div></header><main class=pb7 role=main><article class="cf pa3 pa4-m pa4-l"><div class="measure-wide-l center f4 lh-copy nested-copy-line-height nested-links mid-gray"></div></article><div class="mw8 center"><section class=ph4><h2 class=f1><a href=/tags/architecture/ class="link blue hover-black">Tag: architecture</a></h2><div class="relative w-100 mb4 bg-white nested-copy-line-height"><div class="bg-white mb3 pa4 gray overflow-hidden"><span class="f6 db">Blog</span><h1 class="f3 near-black"><a href=/blog/mcdonald-event-driven-architecture/ class="link black dim">McDonald Event Driven Architecture</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height">簡介 麥當勞，就是早餐滿福堡很好吃的那家，不服來辯
Event Driven Architecture 用於哪些系統 mobile-order progress tracking and sending marketing communications
很明顯都是很經典的應用情境，包含點餐進度追蹤和寄送一些商用訊息
Components 比較特別的是他們有工程友善的 SDK 去處理訊息，包括 schema 檢查，訊息寄送，錯誤處理等等
架構 外部訊息經過 Event Gateway 處理權限驗證等 (此處沒有說明怎樣辦到的) 經過驗證的外部訊息以及內部訊息都會打到 Producer 上面 Producer SDK 經過 Schema validation 後送到 Primary Topic 上 沒過送 Dead-letter 可以自動化處理的錯誤的由 Lambda 重送 其他人工處理後直接送到 Primary Topic 送不出去存 DynamoDB 由 Lambda 重送 Consummers 接收後一樣經過 SDK 去處理 Data governance 符合 Schema validation 就處理 不符合就丟到 Dead-letter Topic ，工人智慧處理 可以快速變更 Schema Cluster autoscaling 這裡比較好玩的是有用到 Step Function 去 Trigger Lambda 做 Partition re-assignment</div></div></div><div class="relative w-100 mb4 bg-white nested-copy-line-height"><div class="bg-white mb3 pa4 gray overflow-hidden"><span class="f6 db">Blog</span><h1 class="f3 near-black"><a href=/blog/aws-architecture-halter/ class="link black dim">AWS Architecture Study Halter</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height">簡介 Halter 提供遠端管理農場的軟體，他們使用一個叫 Collar 的東西放在牛身上
用太陽能為能源 有 GPS 可以發出聲響以及震動 (驅動牛去某個地方) 觀測牛隻健康 有 APP 讓農夫建立虛擬柵欄
AWS 的架構 Collar 使用 wifi, MQTT 以及 IoT Core 將資料送到雲端 除了 wifi 以外，他們使用了 LoRa 協定，將資料送到 station 再由其送至 AWS EC2 上面的資料都會用 binary 的方式送到 Kinesis (由於有兩個 source 所以可能會重複) 去除重複資料後，利用 Lambda 並解成 JSON 格式後送到另一個 Kinesis 利用 Kinesis 做 Data aggregation (by GEO index) 將上面整理好的資料存到 S3 (此處利用農場 ID 當作 partition key) 當使用者要求牛群資料時，會傳送需求到 ECS ECS 傳送運算需求給 Athena 做運算 (十秒可以處理兩千五百萬筆資料) 完成後，ECS 從 S3 獲取 Athena 運算完成的資料，整理後傳給使用者 Key Notes LoRa 可以傳送好幾公里，其資料率可以從 27 Kbps 到 0.</div></div></div><div class="relative w-100 mb4 bg-white nested-copy-line-height"><div class="bg-white mb3 pa4 gray overflow-hidden"><span class="f6 db">Blog</span><h1 class="f3 near-black"><a href=/blog/aws-architecture-mobileye/ class="link black dim">AWS Architecture Study Mobileye</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height">簡介 Mobileye 是提供汽車自駕 (ADAS) 的晶片以及演算法的廠商，依照影片的說明已經有七千萬車輛使用他們家的解決方案
AWS 的架構 車子透過 REST API 傳送資料到 AWS S3 S3 透過更時會觸發 SQS EKS 依照 SQS 的長度去擴增 worker 做資料前處理 EKS 處理完資料後分別送到 AWS Step Function S3 Elasticsearch CockroachDB 最後使用另一套 EKS 作為服務的介面 架構演進 Service Spark streaming, AWS EMR, KAFKA Lambda functions, 為了拆分服務 EKS serve Lambda functions 為了 Scale DB Postgres RDS RIDB, 查了很久，找不到是啥，以下是猜的 Reserved Instance (EC2) for AWS RDS 特規的商用資料庫 可能字幕有問題 為了查詢文件 (document) 使用 Elasticsearch 發現 Elasticsearch 對於經常更新不太友善，使用 CockroachDB 並且將其部署到 EKS 上面，使他們可以 auto scale 還享有高可用性 未來展望 雲端圖像處理 降低成本 Key Notes 為了節省成本，所以儘管有七千萬的車子使用該家產品，但是只有少部分的資料有打到雲端，每天約一千萬的資料量 由於 AWS Lambda 在同時執行 Lambda 是有其帳號上限的 (per account per region)，我猜是因為這樣才轉換到 EKS 上 架構是慢慢演化的 架構之我建 假設</div></div></div><div class="relative w-100 mb4 bg-white nested-copy-line-height"><div class="bg-white mb3 pa4 gray overflow-hidden"><span class="f6 db">Blog</span><h1 class="f3 near-black"><a href=/blog/aws-architecture-study-buzzdial/ class="link black dim">AWS Architecture Study Buzzdial</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height">簡介 Buzzdial 是一家製作電視 Live 節目即時互動的公司，可以想像主持人問答，在家中看電視的你也可以使用 App 與其他相同收看電視的人們互相交流，目前已經找不到網站，看起來應該是已經收掉了，但是還是可以找到相關資訊
遇到的問題 當遇某一特殊事件，導致大量使用者在同一時間使用服務時，需要保證網路以及伺服器可以負荷，並且該特殊事件可能不會天天發生，如果使用傳統架構會需要大量的初始建構成本
導入 AWS 的架構 Buzzdial AWS Architecture 架構拆想 可以看到 Buzzdial 使用了兩個分開的 ASG (auto scale group)，一個是做 Web，另一個是做管理的部分
第一次猜想 可以想像，電視製作或是主持人可以透過 API 去發送事件廣播 (broadcast)，讓所有使用者去看到或是被通知有一個互動發生 (例如：新的題目) Web App 中的 Deamon 可以透過 Logging DB 來通知使用者有新的事件 第二次猜想 We queue those records and store them in our databases to allow us to report back to clients on the success of their broadcast event, and also provide detailed business reports that we review internally.</div></div></div><h2 class=f1><a href=/tags/project/ class="link blue hover-black">Tag: project</a></h2><div class="mb3 pa4 mid-gray overflow-hidden"><div class=f6>April 27, 2021</div><h1 class="f3 near-black"><a href=/blog/python-project-5/ class="link black dim">Python Project (5) Make Automatically</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height">Makefile Makefile 是個很古老的東西，可以把很多東西自動化，以前用來 compile 需要編譯的語言，但是做為自動化的語意，是十分優雅的，這邊我們把之前有用到的套件，利用 Makefile 將他自動化
Usage make &lt;target> Configuration PKG_FILES := $(shell ls requirements/*.txt) build: ## Build this project as pip wheel rm -rf dist/* python setup.py bdist_wheel .PHONY: build dev-install: build ## Install current code into venv pip install -U dist/*.whl pip: ## Recompile and install all pip packages pip-compile requirements/base.in pip-compile --generate-hashes requirements/development.in pip-compile --generate-hashes requirements/deployment.in pip-sync $(PKG_FILES) .PHONY: pip test: dev-install ## Run test only pytest tests .</div></div><div class="mb3 pa4 mid-gray overflow-hidden"><div class=f6>April 25, 2021</div><h1 class="f3 near-black"><a href=/blog/python-project-4/ class="link black dim">Python Project (4) Test More</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height">Python Version Tests 如果專案只是一般服務，可能基本測試就足夠了，但是如果是要寫 Library 給別的專案或是開放給大家使用的話，就要考慮更多的相容性問題，例如： Python 版本，相依套件版本，等等，那一般的測試可能就不足以符合這樣的情境，因此我們需要更多的整合測試
tox 利用 tox 可以測試多種環境，如下圖： 他可以支援 .tox 和 pyproject.toml 但是在 pyproject.toml 裡面是用字串寫舊有設定格式，由於他會先把你的專案，用 setup.py 建立好，用 pip 裝起來後再去執行測試（指令），所以我們要把測試改寫到 tests ，並且儘量用絕對路徑去 import 我們自己的專案，這樣才不會有問題
Usage pip install tox tox -e py38-django31 py38-django31 inst-nodeps: /Users/super/project/prj/.tox/.tmp/package/1/prj-0.1.0.tar.gz py38-django31 installed: asgiref==3.3.4,attrs==20.3.0,coverage==5.5,Django==3.1.8,django-object-actions==3.0.2,prj @ file:///Users/super/project/prj/.tox/.tmp/package/1/prj-0.1.0.tar.gz,iniconfig==1.1.1,packaging==20.9,pluggy==0.13.1,ply==3.11,py==1.10.0,pyparsing==2.4.7,pytest==6.2.3,pytest-cov==2.11.1,pytest-django==4.2.0,python-dateutil==2.8.1,pytz==2021.1,rule-engine==3.2.0,six==1.15.0,sqlparse==0.4.1,toml==0.10.2 py38-django31 run-test-pre: PYTHONHASHSEED='3217434528' py38-django31 run-test: commands[0] | coverage erase py38-django31 run-test: commands[1] | pytest tests ============================= test session starts ============================== platform darwin -- Python 3.8.5, pytest-6.2.3, py-1.10.0, pluggy-0.13.1 -- /Users/super/project/prj/.</div></div><div class="mb3 pa4 mid-gray overflow-hidden"><div class=f6>April 24, 2021</div><h1 class="f3 near-black"><a href=/blog/python-project-3/ class="link black dim">Python Project (3) Test Your Project</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height">Test 寫測試可以減少改壞以前的東西，加速開發，在原生的 Python 就有提供測試的方法 unittest，然而隨著越來越多的套件支援與其脫鉤，如果是開新專案，可以試著從一開始就使用 pytest
Pytest 該套件支援簡單的測試方法，多個套件支援其測試，例如在寫 Django Channels 時異步測試就推薦使用 pytest 可以支援其異步測試，該套件也支援 pyproject.toml 當作設定檔
Usage pip install pytest pytest tests =================================================== test session starts =================================================== platform darwin -- Python 3.8.5, pytest-6.2.3, py-1.10.0, pluggy-0.13.1 -- /Users/super/project/prj/venv/bin/python3 cachedir: .pytest_cache django: settings: settings (from ini) rootdir: /Users/super/project/prj, configfile: pyproject.toml plugins: cov-2.11.1, django-4.1.0 collected 26 items Creating test database for alias 'default'... tests/test_admin/test_actions.py::TestCreateTransformationAction::test_transformation_action_check_fk_values PASSED tests/test_models/test_copy.py::TestInnerCopy::test_copy_to_new_diagram_inner_attr_are_copied PASSED tests/test_models/test_copy.py::TestInnerCopy::test_copy_to_new_diagram_nodes_will_be_copied PASSED tests/test_models/test_copy.py::TestInnerCopy::test_copy_to_new_diagram_transitions_will_be_copied PASSED tests/test_models/test_copy.py::TestDeepCopy::test_copy_to_new_diagram_inner_attr_are_copied PASSED tests/test_models/test_copy.py::TestDeepCopy::test_copy_to_new_diagram_nodes_will_be_copied PASSED tests/test_models/test_copy.</div></div><div class="mb3 pa4 mid-gray overflow-hidden"><div class=f6>April 23, 2021</div><h1 class="f3 near-black"><a href=/blog/python-project-2/ class="link black dim">Python Project (2) Lint Your Project</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height">Lint 程式寫出來不難，但是要寫的好看很難很難，在多人協作時就需要一個標準，讓大家可以寫起來差不多，Python 給出了 PEP (Python Enhancement Proposals) 8 Style Guide for Python Code 當然正常人不會去看完，所以有工具幫忙就很重要了，這邊介紹 falke8, black, isort 等，工具，方便統一 Coding Style
Flake8 Flake8 可以檢查專案是否符合 PEP 8 ，然而，該檢查有些過時或是有些規範是相互違反的，這部分就有待團隊自行去規定，此時就需要設定他，Flake8 支援 setup.cfg, tox.ini, 或 .flake8 檔，作為設定，此處為了減少檔案，我們使用上次使用到的 setup.cfg 作為我們的設定檔
Usage 裝好該指令後就可以對你的專案進行檢查
pip3 install flake8 flake8 Max Line Length PEP 8 最常被調整的設定就是其每一行程式碼不可超過的字數，該設定原本為每一行不可以超過 79 字元，其由來是以前的 Terminal 長度為 80 字元，為了不讓他換行，所以建議使用該設定，但是現在螢幕都很寬，所以我們可以與團隊溝通調整最大長度
# setup.cfg [flake8] max-line-length = 88 Exclude 某些檔案可能是由機器自動產生的，你不希望被納入控管，可以使用 exclude 的設定讓他跳過該檔案或目錄，這邊以 Django 的 migration file (機器產生)，以及常見虛擬環境目錄 (他人專案) 作為範例
#setup.cfg [flake8] exclude = */migrations/,env/,venv/ Ignore 在 PEP 8 中不少警告是對立的，如：W503、W504，他們的 Best practice 剛好是對方的 Anti-pattern 團隊們可以選擇對於團隊而言比較好的選項，此時我們就可以忽略該筆檢查</div></div><div class="mb3 pa4 mid-gray overflow-hidden"><div class=f6>April 22, 2021</div><h1 class="f3 near-black"><a href=/blog/python-project-1/ class="link black dim">Python Project (1) setup.py setup.cfg</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height">Create Project 開專案一直以來都不是一個簡單的事情，專案開的好可以讓後面的開發更有效率，團隊也可以有比較一致開發準則，接下來幾篇文章會大該說說之前研究開 Python 專案的一些經驗
Create setup.py For Install 如果專案要可以被安裝，就需要寫這檔案，裡面可寫詳述該套件需要裝哪些東西，以及一些資訊，建議放在專案的根目錄，這樣別人就可以直接用你的 Git Repo 去安裝你的套件
from pathlib import Path from setuptools import find_packages, setup REPO_URL = "https://github.com/lambdaTW/python-project" def get_version(rel_path): for line in Path(rel_path).open().read().splitlines(): if line.startswith("__version__"): delim = '"' if '"' in line else "'" return line.split(delim)[1] raise RuntimeError("Unable to find version string.") setup( name="python-project", version=get_version("src/python-project/__init__.py"), description="My python project", long_description=Path("README.md").open().read(), long_description_content_type="text/markdown", python_requires=">=3.8", classifiers=[ "Programming Language :: Python :: 3.8", ], keywords=["python", "project"], url=REPO_URL, author="lambdaTW", author_email="lambda@lambda.</div></div><h2 class=f1><a href=/tags/python/ class="link blue hover-black">Tag: python</a></h2><div class="mb3 pa4 mid-gray overflow-hidden"><div class=f6>April 27, 2021</div><h1 class="f3 near-black"><a href=/blog/python-project-5/ class="link black dim">Python Project (5) Make Automatically</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height">Makefile Makefile 是個很古老的東西，可以把很多東西自動化，以前用來 compile 需要編譯的語言，但是做為自動化的語意，是十分優雅的，這邊我們把之前有用到的套件，利用 Makefile 將他自動化
Usage make &lt;target> Configuration PKG_FILES := $(shell ls requirements/*.txt) build: ## Build this project as pip wheel rm -rf dist/* python setup.py bdist_wheel .PHONY: build dev-install: build ## Install current code into venv pip install -U dist/*.whl pip: ## Recompile and install all pip packages pip-compile requirements/base.in pip-compile --generate-hashes requirements/development.in pip-compile --generate-hashes requirements/deployment.in pip-sync $(PKG_FILES) .PHONY: pip test: dev-install ## Run test only pytest tests .</div></div><div class="mb3 pa4 mid-gray overflow-hidden"><div class=f6>April 25, 2021</div><h1 class="f3 near-black"><a href=/blog/python-project-4/ class="link black dim">Python Project (4) Test More</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height">Python Version Tests 如果專案只是一般服務，可能基本測試就足夠了，但是如果是要寫 Library 給別的專案或是開放給大家使用的話，就要考慮更多的相容性問題，例如： Python 版本，相依套件版本，等等，那一般的測試可能就不足以符合這樣的情境，因此我們需要更多的整合測試
tox 利用 tox 可以測試多種環境，如下圖： 他可以支援 .tox 和 pyproject.toml 但是在 pyproject.toml 裡面是用字串寫舊有設定格式，由於他會先把你的專案，用 setup.py 建立好，用 pip 裝起來後再去執行測試（指令），所以我們要把測試改寫到 tests ，並且儘量用絕對路徑去 import 我們自己的專案，這樣才不會有問題
Usage pip install tox tox -e py38-django31 py38-django31 inst-nodeps: /Users/super/project/prj/.tox/.tmp/package/1/prj-0.1.0.tar.gz py38-django31 installed: asgiref==3.3.4,attrs==20.3.0,coverage==5.5,Django==3.1.8,django-object-actions==3.0.2,prj @ file:///Users/super/project/prj/.tox/.tmp/package/1/prj-0.1.0.tar.gz,iniconfig==1.1.1,packaging==20.9,pluggy==0.13.1,ply==3.11,py==1.10.0,pyparsing==2.4.7,pytest==6.2.3,pytest-cov==2.11.1,pytest-django==4.2.0,python-dateutil==2.8.1,pytz==2021.1,rule-engine==3.2.0,six==1.15.0,sqlparse==0.4.1,toml==0.10.2 py38-django31 run-test-pre: PYTHONHASHSEED='3217434528' py38-django31 run-test: commands[0] | coverage erase py38-django31 run-test: commands[1] | pytest tests ============================= test session starts ============================== platform darwin -- Python 3.8.5, pytest-6.2.3, py-1.10.0, pluggy-0.13.1 -- /Users/super/project/prj/.</div></div><div class="mb3 pa4 mid-gray overflow-hidden"><div class=f6>April 24, 2021</div><h1 class="f3 near-black"><a href=/blog/python-project-3/ class="link black dim">Python Project (3) Test Your Project</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height">Test 寫測試可以減少改壞以前的東西，加速開發，在原生的 Python 就有提供測試的方法 unittest，然而隨著越來越多的套件支援與其脫鉤，如果是開新專案，可以試著從一開始就使用 pytest
Pytest 該套件支援簡單的測試方法，多個套件支援其測試，例如在寫 Django Channels 時異步測試就推薦使用 pytest 可以支援其異步測試，該套件也支援 pyproject.toml 當作設定檔
Usage pip install pytest pytest tests =================================================== test session starts =================================================== platform darwin -- Python 3.8.5, pytest-6.2.3, py-1.10.0, pluggy-0.13.1 -- /Users/super/project/prj/venv/bin/python3 cachedir: .pytest_cache django: settings: settings (from ini) rootdir: /Users/super/project/prj, configfile: pyproject.toml plugins: cov-2.11.1, django-4.1.0 collected 26 items Creating test database for alias 'default'... tests/test_admin/test_actions.py::TestCreateTransformationAction::test_transformation_action_check_fk_values PASSED tests/test_models/test_copy.py::TestInnerCopy::test_copy_to_new_diagram_inner_attr_are_copied PASSED tests/test_models/test_copy.py::TestInnerCopy::test_copy_to_new_diagram_nodes_will_be_copied PASSED tests/test_models/test_copy.py::TestInnerCopy::test_copy_to_new_diagram_transitions_will_be_copied PASSED tests/test_models/test_copy.py::TestDeepCopy::test_copy_to_new_diagram_inner_attr_are_copied PASSED tests/test_models/test_copy.py::TestDeepCopy::test_copy_to_new_diagram_nodes_will_be_copied PASSED tests/test_models/test_copy.</div></div><div class="mb3 pa4 mid-gray overflow-hidden"><div class=f6>April 23, 2021</div><h1 class="f3 near-black"><a href=/blog/python-project-2/ class="link black dim">Python Project (2) Lint Your Project</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height">Lint 程式寫出來不難，但是要寫的好看很難很難，在多人協作時就需要一個標準，讓大家可以寫起來差不多，Python 給出了 PEP (Python Enhancement Proposals) 8 Style Guide for Python Code 當然正常人不會去看完，所以有工具幫忙就很重要了，這邊介紹 falke8, black, isort 等，工具，方便統一 Coding Style
Flake8 Flake8 可以檢查專案是否符合 PEP 8 ，然而，該檢查有些過時或是有些規範是相互違反的，這部分就有待團隊自行去規定，此時就需要設定他，Flake8 支援 setup.cfg, tox.ini, 或 .flake8 檔，作為設定，此處為了減少檔案，我們使用上次使用到的 setup.cfg 作為我們的設定檔
Usage 裝好該指令後就可以對你的專案進行檢查
pip3 install flake8 flake8 Max Line Length PEP 8 最常被調整的設定就是其每一行程式碼不可超過的字數，該設定原本為每一行不可以超過 79 字元，其由來是以前的 Terminal 長度為 80 字元，為了不讓他換行，所以建議使用該設定，但是現在螢幕都很寬，所以我們可以與團隊溝通調整最大長度
# setup.cfg [flake8] max-line-length = 88 Exclude 某些檔案可能是由機器自動產生的，你不希望被納入控管，可以使用 exclude 的設定讓他跳過該檔案或目錄，這邊以 Django 的 migration file (機器產生)，以及常見虛擬環境目錄 (他人專案) 作為範例
#setup.cfg [flake8] exclude = */migrations/,env/,venv/ Ignore 在 PEP 8 中不少警告是對立的，如：W503、W504，他們的 Best practice 剛好是對方的 Anti-pattern 團隊們可以選擇對於團隊而言比較好的選項，此時我們就可以忽略該筆檢查</div></div><div class="mb3 pa4 mid-gray overflow-hidden"><div class=f6>April 22, 2021</div><h1 class="f3 near-black"><a href=/blog/python-project-1/ class="link black dim">Python Project (1) setup.py setup.cfg</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height">Create Project 開專案一直以來都不是一個簡單的事情，專案開的好可以讓後面的開發更有效率，團隊也可以有比較一致開發準則，接下來幾篇文章會大該說說之前研究開 Python 專案的一些經驗
Create setup.py For Install 如果專案要可以被安裝，就需要寫這檔案，裡面可寫詳述該套件需要裝哪些東西，以及一些資訊，建議放在專案的根目錄，這樣別人就可以直接用你的 Git Repo 去安裝你的套件
from pathlib import Path from setuptools import find_packages, setup REPO_URL = "https://github.com/lambdaTW/python-project" def get_version(rel_path): for line in Path(rel_path).open().read().splitlines(): if line.startswith("__version__"): delim = '"' if '"' in line else "'" return line.split(delim)[1] raise RuntimeError("Unable to find version string.") setup( name="python-project", version=get_version("src/python-project/__init__.py"), description="My python project", long_description=Path("README.md").open().read(), long_description_content_type="text/markdown", python_requires=">=3.8", classifiers=[ "Programming Language :: Python :: 3.8", ], keywords=["python", "project"], url=REPO_URL, author="lambdaTW", author_email="lambda@lambda.</div></div><div class="mb3 pa4 mid-gray overflow-hidden"><div class=f6>April 18, 2019</div><h1 class="f3 near-black"><a href=/blog/closure/ class="link black dim">Closure</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height">Closure What is closure Closure 簡單來說，就是某函數在另一個函數內被創造並且參照了創建函數的某些變數，此時該變數會存留於記憶內，儘管創建函數已經結束。
First time meet to Closure N年前在學習 Common Lisp 時教學內出現了一個陌生又奇特的技巧，Closure，以下是他的實做
(let ((counter 0)) (defun reset () (setf counter 0)) (defun stamp () (setf counter (+ counter 1)))) (list (stamp) (stamp) (reset) (stamp)) ; (1 2 0 1) 為了怕正常人看不懂，以下用 Python 翻譯
def gen_counter(): counter = 0 def reset(): nonlocal counter counter = 0 return counter def stamp(): nonlocal counter counter += 1 return counter return reset, stamp reset, stamp = gen_counter() print(stamp()) # 1 print(stamp()) # 2 print(reset()) # 0 print(stamp()) # 1 可以看出在 gen_counter 內的 兩個函數 (reset, stamp) 一同共用內部變數 counter 儘管 gen_counter 已經回傳並且結束，但是在之後的程式卻還是擁有當初初始化的 count，亦即 counter 在記憶體中不會因為 gen_counter 已經回傳就被回收。</div></div><h2 class=f1><a href=/tags/test/ class="link blue hover-black">Tag: test</a></h2><div class="mb3 pa4 mid-gray overflow-hidden"><div class=f6>April 25, 2021</div><h1 class="f3 near-black"><a href=/blog/python-project-4/ class="link black dim">Python Project (4) Test More</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height">Python Version Tests 如果專案只是一般服務，可能基本測試就足夠了，但是如果是要寫 Library 給別的專案或是開放給大家使用的話，就要考慮更多的相容性問題，例如： Python 版本，相依套件版本，等等，那一般的測試可能就不足以符合這樣的情境，因此我們需要更多的整合測試
tox 利用 tox 可以測試多種環境，如下圖： 他可以支援 .tox 和 pyproject.toml 但是在 pyproject.toml 裡面是用字串寫舊有設定格式，由於他會先把你的專案，用 setup.py 建立好，用 pip 裝起來後再去執行測試（指令），所以我們要把測試改寫到 tests ，並且儘量用絕對路徑去 import 我們自己的專案，這樣才不會有問題
Usage pip install tox tox -e py38-django31 py38-django31 inst-nodeps: /Users/super/project/prj/.tox/.tmp/package/1/prj-0.1.0.tar.gz py38-django31 installed: asgiref==3.3.4,attrs==20.3.0,coverage==5.5,Django==3.1.8,django-object-actions==3.0.2,prj @ file:///Users/super/project/prj/.tox/.tmp/package/1/prj-0.1.0.tar.gz,iniconfig==1.1.1,packaging==20.9,pluggy==0.13.1,ply==3.11,py==1.10.0,pyparsing==2.4.7,pytest==6.2.3,pytest-cov==2.11.1,pytest-django==4.2.0,python-dateutil==2.8.1,pytz==2021.1,rule-engine==3.2.0,six==1.15.0,sqlparse==0.4.1,toml==0.10.2 py38-django31 run-test-pre: PYTHONHASHSEED='3217434528' py38-django31 run-test: commands[0] | coverage erase py38-django31 run-test: commands[1] | pytest tests ============================= test session starts ============================== platform darwin -- Python 3.8.5, pytest-6.2.3, py-1.10.0, pluggy-0.13.1 -- /Users/super/project/prj/.</div></div><div class="mb3 pa4 mid-gray overflow-hidden"><div class=f6>April 24, 2021</div><h1 class="f3 near-black"><a href=/blog/python-project-3/ class="link black dim">Python Project (3) Test Your Project</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height">Test 寫測試可以減少改壞以前的東西，加速開發，在原生的 Python 就有提供測試的方法 unittest，然而隨著越來越多的套件支援與其脫鉤，如果是開新專案，可以試著從一開始就使用 pytest
Pytest 該套件支援簡單的測試方法，多個套件支援其測試，例如在寫 Django Channels 時異步測試就推薦使用 pytest 可以支援其異步測試，該套件也支援 pyproject.toml 當作設定檔
Usage pip install pytest pytest tests =================================================== test session starts =================================================== platform darwin -- Python 3.8.5, pytest-6.2.3, py-1.10.0, pluggy-0.13.1 -- /Users/super/project/prj/venv/bin/python3 cachedir: .pytest_cache django: settings: settings (from ini) rootdir: /Users/super/project/prj, configfile: pyproject.toml plugins: cov-2.11.1, django-4.1.0 collected 26 items Creating test database for alias 'default'... tests/test_admin/test_actions.py::TestCreateTransformationAction::test_transformation_action_check_fk_values PASSED tests/test_models/test_copy.py::TestInnerCopy::test_copy_to_new_diagram_inner_attr_are_copied PASSED tests/test_models/test_copy.py::TestInnerCopy::test_copy_to_new_diagram_nodes_will_be_copied PASSED tests/test_models/test_copy.py::TestInnerCopy::test_copy_to_new_diagram_transitions_will_be_copied PASSED tests/test_models/test_copy.py::TestDeepCopy::test_copy_to_new_diagram_inner_attr_are_copied PASSED tests/test_models/test_copy.py::TestDeepCopy::test_copy_to_new_diagram_nodes_will_be_copied PASSED tests/test_models/test_copy.</div></div><h2 class=f1><a href=/tags/django/ class="link blue hover-black">Tag: django</a></h2><div class="mb3 pa4 mid-gray overflow-hidden"><div class=f6>January 25, 2020</div><h1 class="f3 near-black"><a href=/blog/how-to-fix-no-route-found-error-on-django-channels/ class="link black dim">How to fix no route found error on Django Channels</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height">Issue description Django Channels 對於不存在的路徑存取，全部會拋出錯誤，而不是一般性的警告處理，所以如果和我一樣在 Djangoo Channels 有裝上 Sentry ，而且伺服器在被惡意嘗試路徑時就會看到一堆 ValueError: No route found for path '...'. 的錯誤資訊，好處是知道被打了，壞處就是會噴錢（如果不是自己 Hosting）。
Fix it Make HandleRouteNotFoundMiddleware for this issue from datetime import datetime from logging import getLogger from django.urls.exceptions import Resolver404 logger = getLogger(__file__) class HandleRouteNotFoundMiddleware: def __init__(self, inner): self.inner = inner def __call__(self, scope): try: inner_instance = self.inner(scope) return inner_instance except (Resolver404, ValueError) as e: if 'No route found for path' not in str(e) and \ scope["type"] not in ['http', 'websocket']: raise e logger.</div></div><div class="mb3 pa4 mid-gray overflow-hidden"><div class=f6>April 26, 2019</div><h1 class="f3 near-black"><a href=/blog/create-a-gin-index-with-django-on-aws-rds/ class="link black dim">Create a GIN index with Django on AWS RDS</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height">GIN What is it GIN 是一種 INDEX 可以幫助加速全文搜索的速度
GIN stands for Generalized Inverted Index. GIN is designed for handling cases where the items to be indexed are composite values, and the queries to be handled by the index need to search for element values that appear within the composite items. For example, the items could be documents, and the queries could be searches for documents containing specific words.
Normal SQL 在傳統 SQL 下可以用以下幾個步驟完成建立 GIN INDEX</div></div><div class="mb3 pa4 mid-gray overflow-hidden"><div class=f6>April 18, 2019</div><h1 class="f3 near-black"><a href=/blog/closure/ class="link black dim">Closure</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height">Closure What is closure Closure 簡單來說，就是某函數在另一個函數內被創造並且參照了創建函數的某些變數，此時該變數會存留於記憶內，儘管創建函數已經結束。
First time meet to Closure N年前在學習 Common Lisp 時教學內出現了一個陌生又奇特的技巧，Closure，以下是他的實做
(let ((counter 0)) (defun reset () (setf counter 0)) (defun stamp () (setf counter (+ counter 1)))) (list (stamp) (stamp) (reset) (stamp)) ; (1 2 0 1) 為了怕正常人看不懂，以下用 Python 翻譯
def gen_counter(): counter = 0 def reset(): nonlocal counter counter = 0 return counter def stamp(): nonlocal counter counter += 1 return counter return reset, stamp reset, stamp = gen_counter() print(stamp()) # 1 print(stamp()) # 2 print(reset()) # 0 print(stamp()) # 1 可以看出在 gen_counter 內的 兩個函數 (reset, stamp) 一同共用內部變數 counter 儘管 gen_counter 已經回傳並且結束，但是在之後的程式卻還是擁有當初初始化的 count，亦即 counter 在記憶體中不會因為 gen_counter 已經回傳就被回收。</div></div><h2 class=f1><a href=/tags/django-channels/ class="link blue hover-black">Tag: Django Channels</a></h2><div class="mb3 pa4 mid-gray overflow-hidden"><div class=f6>January 25, 2020</div><h1 class="f3 near-black"><a href=/blog/how-to-fix-no-route-found-error-on-django-channels/ class="link black dim">How to fix no route found error on Django Channels</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height">Issue description Django Channels 對於不存在的路徑存取，全部會拋出錯誤，而不是一般性的警告處理，所以如果和我一樣在 Djangoo Channels 有裝上 Sentry ，而且伺服器在被惡意嘗試路徑時就會看到一堆 ValueError: No route found for path '...'. 的錯誤資訊，好處是知道被打了，壞處就是會噴錢（如果不是自己 Hosting）。
Fix it Make HandleRouteNotFoundMiddleware for this issue from datetime import datetime from logging import getLogger from django.urls.exceptions import Resolver404 logger = getLogger(__file__) class HandleRouteNotFoundMiddleware: def __init__(self, inner): self.inner = inner def __call__(self, scope): try: inner_instance = self.inner(scope) return inner_instance except (Resolver404, ValueError) as e: if 'No route found for path' not in str(e) and \ scope["type"] not in ['http', 'websocket']: raise e logger.</div></div><h2 class=f1><a href=/tags/middleware/ class="link blue hover-black">Tag: Middleware</a></h2><div class="mb3 pa4 mid-gray overflow-hidden"><div class=f6>January 25, 2020</div><h1 class="f3 near-black"><a href=/blog/how-to-fix-no-route-found-error-on-django-channels/ class="link black dim">How to fix no route found error on Django Channels</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height">Issue description Django Channels 對於不存在的路徑存取，全部會拋出錯誤，而不是一般性的警告處理，所以如果和我一樣在 Djangoo Channels 有裝上 Sentry ，而且伺服器在被惡意嘗試路徑時就會看到一堆 ValueError: No route found for path '...'. 的錯誤資訊，好處是知道被打了，壞處就是會噴錢（如果不是自己 Hosting）。
Fix it Make HandleRouteNotFoundMiddleware for this issue from datetime import datetime from logging import getLogger from django.urls.exceptions import Resolver404 logger = getLogger(__file__) class HandleRouteNotFoundMiddleware: def __init__(self, inner): self.inner = inner def __call__(self, scope): try: inner_instance = self.inner(scope) return inner_instance except (Resolver404, ValueError) as e: if 'No route found for path' not in str(e) and \ scope["type"] not in ['http', 'websocket']: raise e logger.</div></div><h2 class=f1><a href=/tags/aws/ class="link blue hover-black">Tag: AWS</a></h2><div class="mb3 pa4 mid-gray overflow-hidden"><div class=f6>April 26, 2019</div><h1 class="f3 near-black"><a href=/blog/create-a-gin-index-with-django-on-aws-rds/ class="link black dim">Create a GIN index with Django on AWS RDS</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height">GIN What is it GIN 是一種 INDEX 可以幫助加速全文搜索的速度
GIN stands for Generalized Inverted Index. GIN is designed for handling cases where the items to be indexed are composite values, and the queries to be handled by the index need to search for element values that appear within the composite items. For example, the items could be documents, and the queries could be searches for documents containing specific words.
Normal SQL 在傳統 SQL 下可以用以下幾個步驟完成建立 GIN INDEX</div></div><h2 class=f1><a href=/tags/index/ class="link blue hover-black">Tag: Index</a></h2><div class="mb3 pa4 mid-gray overflow-hidden"><div class=f6>April 26, 2019</div><h1 class="f3 near-black"><a href=/blog/create-a-gin-index-with-django-on-aws-rds/ class="link black dim">Create a GIN index with Django on AWS RDS</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height">GIN What is it GIN 是一種 INDEX 可以幫助加速全文搜索的速度
GIN stands for Generalized Inverted Index. GIN is designed for handling cases where the items to be indexed are composite values, and the queries to be handled by the index need to search for element values that appear within the composite items. For example, the items could be documents, and the queries could be searches for documents containing specific words.
Normal SQL 在傳統 SQL 下可以用以下幾個步驟完成建立 GIN INDEX</div></div><h2 class=f1><a href=/tags/postgres/ class="link blue hover-black">Tag: postgres</a></h2><div class="mb3 pa4 mid-gray overflow-hidden"><div class=f6>April 26, 2019</div><h1 class="f3 near-black"><a href=/blog/create-a-gin-index-with-django-on-aws-rds/ class="link black dim">Create a GIN index with Django on AWS RDS</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height">GIN What is it GIN 是一種 INDEX 可以幫助加速全文搜索的速度
GIN stands for Generalized Inverted Index. GIN is designed for handling cases where the items to be indexed are composite values, and the queries to be handled by the index need to search for element values that appear within the composite items. For example, the items could be documents, and the queries could be searches for documents containing specific words.
Normal SQL 在傳統 SQL 下可以用以下幾個步驟完成建立 GIN INDEX</div></div><h2 class=f1><a href=/tags/rds/ class="link blue hover-black">Tag: RDS</a></h2><div class="mb3 pa4 mid-gray overflow-hidden"><div class=f6>April 26, 2019</div><h1 class="f3 near-black"><a href=/blog/create-a-gin-index-with-django-on-aws-rds/ class="link black dim">Create a GIN index with Django on AWS RDS</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height">GIN What is it GIN 是一種 INDEX 可以幫助加速全文搜索的速度
GIN stands for Generalized Inverted Index. GIN is designed for handling cases where the items to be indexed are composite values, and the queries to be handled by the index need to search for element values that appear within the composite items. For example, the items could be documents, and the queries could be searches for documents containing specific words.
Normal SQL 在傳統 SQL 下可以用以下幾個步驟完成建立 GIN INDEX</div></div><h2 class=f1><a href=/tags/closure/ class="link blue hover-black">Tag: closure</a></h2><div class="mb3 pa4 mid-gray overflow-hidden"><div class=f6>April 18, 2019</div><h1 class="f3 near-black"><a href=/blog/closure/ class="link black dim">Closure</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height">Closure What is closure Closure 簡單來說，就是某函數在另一個函數內被創造並且參照了創建函數的某些變數，此時該變數會存留於記憶內，儘管創建函數已經結束。
First time meet to Closure N年前在學習 Common Lisp 時教學內出現了一個陌生又奇特的技巧，Closure，以下是他的實做
(let ((counter 0)) (defun reset () (setf counter 0)) (defun stamp () (setf counter (+ counter 1)))) (list (stamp) (stamp) (reset) (stamp)) ; (1 2 0 1) 為了怕正常人看不懂，以下用 Python 翻譯
def gen_counter(): counter = 0 def reset(): nonlocal counter counter = 0 return counter def stamp(): nonlocal counter counter += 1 return counter return reset, stamp reset, stamp = gen_counter() print(stamp()) # 1 print(stamp()) # 2 print(reset()) # 0 print(stamp()) # 1 可以看出在 gen_counter 內的 兩個函數 (reset, stamp) 一同共用內部變數 counter 儘管 gen_counter 已經回傳並且結束，但是在之後的程式卻還是擁有當初初始化的 count，亦即 counter 在記憶體中不會因為 gen_counter 已經回傳就被回收。</div></div><h2 class=f1><a href=/tags/django-q/ class="link blue hover-black">Tag: django q</a></h2><div class="mb3 pa4 mid-gray overflow-hidden"><div class=f6>April 18, 2019</div><h1 class="f3 near-black"><a href=/blog/closure/ class="link black dim">Closure</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height">Closure What is closure Closure 簡單來說，就是某函數在另一個函數內被創造並且參照了創建函數的某些變數，此時該變數會存留於記憶內，儘管創建函數已經結束。
First time meet to Closure N年前在學習 Common Lisp 時教學內出現了一個陌生又奇特的技巧，Closure，以下是他的實做
(let ((counter 0)) (defun reset () (setf counter 0)) (defun stamp () (setf counter (+ counter 1)))) (list (stamp) (stamp) (reset) (stamp)) ; (1 2 0 1) 為了怕正常人看不懂，以下用 Python 翻譯
def gen_counter(): counter = 0 def reset(): nonlocal counter counter = 0 return counter def stamp(): nonlocal counter counter += 1 return counter return reset, stamp reset, stamp = gen_counter() print(stamp()) # 1 print(stamp()) # 2 print(reset()) # 0 print(stamp()) # 1 可以看出在 gen_counter 內的 兩個函數 (reset, stamp) 一同共用內部變數 counter 儘管 gen_counter 已經回傳並且結束，但是在之後的程式卻還是擁有當初初始化的 count，亦即 counter 在記憶體中不會因為 gen_counter 已經回傳就被回收。</div></div><h2 class=f1><a href=/tags/lisp/ class="link blue hover-black">Tag: lisp</a></h2><div class="mb3 pa4 mid-gray overflow-hidden"><div class=f6>April 18, 2019</div><h1 class="f3 near-black"><a href=/blog/closure/ class="link black dim">Closure</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height">Closure What is closure Closure 簡單來說，就是某函數在另一個函數內被創造並且參照了創建函數的某些變數，此時該變數會存留於記憶內，儘管創建函數已經結束。
First time meet to Closure N年前在學習 Common Lisp 時教學內出現了一個陌生又奇特的技巧，Closure，以下是他的實做
(let ((counter 0)) (defun reset () (setf counter 0)) (defun stamp () (setf counter (+ counter 1)))) (list (stamp) (stamp) (reset) (stamp)) ; (1 2 0 1) 為了怕正常人看不懂，以下用 Python 翻譯
def gen_counter(): counter = 0 def reset(): nonlocal counter counter = 0 return counter def stamp(): nonlocal counter counter += 1 return counter return reset, stamp reset, stamp = gen_counter() print(stamp()) # 1 print(stamp()) # 2 print(reset()) # 0 print(stamp()) # 1 可以看出在 gen_counter 內的 兩個函數 (reset, stamp) 一同共用內部變數 counter 儘管 gen_counter 已經回傳並且結束，但是在之後的程式卻還是擁有當初初始化的 count，亦即 counter 在記憶體中不會因為 gen_counter 已經回傳就被回收。</div></div><h2 class=f1><a href=/tags/golang/ class="link blue hover-black">Tag: Golang</a></h2><div class="mb3 pa4 mid-gray overflow-hidden"><div class=f6>November 18, 2018</div><h1 class="f3 near-black"><a href=/blog/grpc/ class="link black dim">gRPC</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height">實做一個可以寄信的 gRPC Proto 寫一個寄發信件服務所需要的資料格式 Proto 是一個文件用來儲存 gRPC server 與 client 交換資料時鎖需要的資料格式，建議可以看看它與 JSON 的對照表來迅速了解需要怎樣寫
syntax = "proto3"; // use proto version 3 package pb; // package name /* Add the Send function for use */ service Mail{ rpc Send (MailRequest) returns (MailStatus) {} } /* Declare what data you need to let server know and server will use it to send a mail */ message MailRequest{ string from = 1; repeated string to = 2; repeated string cc = 3; string subject = 4; string body = 5; string type = 6; } /* Means what the mail status be send or not */ message MailStatus{ int32 status = 1; string code = 2; } 產生 golang 的程式 go get -u github.</div></div><div class="mb3 pa4 mid-gray overflow-hidden"><div class=f6>August 5, 2018</div><h1 class="f3 near-black"><a href=/blog/golangquicksort/ class="link black dim">GolangQuickSort</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height">用 Golang 實做快速排序 (quick sort) 快速排序是很常用的一個排序方法，下方我將會用 Golang 實做同步以及異步的快速排序。
同步 實做 func sort(list []int, center int) (complete []int) { left := []int{} right := []int{} for _, num := range list[:center] { if num &lt;= list[center] { left = append(left, num) } else { right = append(right, num) } } if len(list) > center+1 { for _, num := range list[center+1:] { if num &lt;= list[center] { left = append(left, num) } else { right = append(right, num) } } } if len(left) > 1 { left = sort(left, len(left)/2) } if len(right) > 1 { right = sort(right, len(right)/2) } return append(append(left, list[center]), right.</div></div><div class="mb3 pa4 mid-gray overflow-hidden"><div class=f6>July 21, 2018</div><h1 class="f3 near-black"><a href=/blog/golanghttphandler/ class="link black dim">GolangHTTPHandler</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height">簡易復刻出的 Golang HTTP HandleFunc 身為一個 web 狗，用新語言寫個 router 也是應該的，Golang 本身在寫 HTTP 服務就有極大的優勢，官方自帶的 library 就很好用了，以至於到目前為止的統計大部分的人還是直接使用原生的 library 而非使用框架，但是 router 這部份就統計看來已經有了大方向， Mux 是目前大多數人使用的 router 框架，這邊我們玩一下 Golang 原生的 handler 讓它可以和原生的 HandleFunc 有一樣的感覺
第一步：寫一個簡單的 HTTP server 相信大家都不會。。。當然就是要 google
關鍵字 ： golang http
第一篇就會看到官方的 library 的連結囉！
開一個新專案 cd $GOPATH/src/ mkdir router touch main.go 依照官方網站的提示寫出一個簡單的 HTTP 服務 package main import ( "fmt" "net/http" "html" "log" ) func main() { http.HandleFunc("/bar", func(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, "Hello, %q", html.</div></div><div class="mb3 pa4 mid-gray overflow-hidden"><div class=f6>July 12, 2018</div><h1 class="f3 near-black"><a href=/blog/finderrornumber/ class="link black dim">FindErrorNumber</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height">找出錯誤的數字，使用 Golang 題目 在輸入一連串的數字中(從一開始連續[1, 2, 3, 4, 5, 6])找到錯誤(重複)的數字，並且把錯誤的先列出來再將正確的數字附加到到後面
輸入 [1,2,2,4] [1,2,2,4,5,5,7] 輸出 [2,3] [2,5,3,6] 實做 main.go package main import "fmt" func findErrorNums(nums []int) (ret []int) { dict := make(map[int]int) for _, num := range nums { _, ok := dict[num] if ok { ret = append(ret, num) } else { dict[num] = num } } for i := 1; i &lt;= len(nums); i++ { _, ok := dict[i] if !</div></div><div class="mb3 pa4 mid-gray overflow-hidden"><div class=f6>July 4, 2018</div><h1 class="f3 near-black"><a href=/blog/helloworld/ class="link black dim">Hello Golang</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height">Golang 這篇文章將從頭開始說起 Golang 的基本
安裝 Golang 在 archlinux 上面安裝很簡單下以下指令
sudo pacman -S go 設定 Golang 基本環境變數 # super 是我的 使用者名稱 export GOPATH=/home/super/go export GOBIN=/home/super/go/bin export PATH=$PATH:$GOBIN 編輯器 我大部分還是習慣在 emacs 上開發，但是沒在使用 vim 或是 emacs 的人還是建議使用 vscode 比較方便
安裝 vscode curl -O https://aur.archlinux.org/cgit/aur.git/snapshot/visual-studio-code-bin.tar.gz tar -xvz -f visual-studio-code-bin.tar.gz cd visual-studio-code-bin makepkg -sir . 設定 Golang 按下安裝 vscode 建議的 extension (選擇 install)
重新載入 vscode (選擇 reload)
寫下你的第一支程式 進入你的家目錄中的 go/src 資料夾 裡面建立你的第一支程式的目錄 hello mkdir -p ~/go/src/hello cd ~/go/src/hello 用 vscode 打開 code main.</div></div><h2 class=f1><a href=/tags/grpc/ class="link blue hover-black">Tag: gRPC</a></h2><div class="mb3 pa4 mid-gray overflow-hidden"><div class=f6>November 18, 2018</div><h1 class="f3 near-black"><a href=/blog/grpc/ class="link black dim">gRPC</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height">實做一個可以寄信的 gRPC Proto 寫一個寄發信件服務所需要的資料格式 Proto 是一個文件用來儲存 gRPC server 與 client 交換資料時鎖需要的資料格式，建議可以看看它與 JSON 的對照表來迅速了解需要怎樣寫
syntax = "proto3"; // use proto version 3 package pb; // package name /* Add the Send function for use */ service Mail{ rpc Send (MailRequest) returns (MailStatus) {} } /* Declare what data you need to let server know and server will use it to send a mail */ message MailRequest{ string from = 1; repeated string to = 2; repeated string cc = 3; string subject = 4; string body = 5; string type = 6; } /* Means what the mail status be send or not */ message MailStatus{ int32 status = 1; string code = 2; } 產生 golang 的程式 go get -u github.</div></div><h2 class=f1><a href=/tags/http/ class="link blue hover-black">Tag: HTTP</a></h2><div class="mb3 pa4 mid-gray overflow-hidden"><div class=f6>July 21, 2018</div><h1 class="f3 near-black"><a href=/blog/golanghttphandler/ class="link black dim">GolangHTTPHandler</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height">簡易復刻出的 Golang HTTP HandleFunc 身為一個 web 狗，用新語言寫個 router 也是應該的，Golang 本身在寫 HTTP 服務就有極大的優勢，官方自帶的 library 就很好用了，以至於到目前為止的統計大部分的人還是直接使用原生的 library 而非使用框架，但是 router 這部份就統計看來已經有了大方向， Mux 是目前大多數人使用的 router 框架，這邊我們玩一下 Golang 原生的 handler 讓它可以和原生的 HandleFunc 有一樣的感覺
第一步：寫一個簡單的 HTTP server 相信大家都不會。。。當然就是要 google
關鍵字 ： golang http
第一篇就會看到官方的 library 的連結囉！
開一個新專案 cd $GOPATH/src/ mkdir router touch main.go 依照官方網站的提示寫出一個簡單的 HTTP 服務 package main import ( "fmt" "net/http" "html" "log" ) func main() { http.HandleFunc("/bar", func(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, "Hello, %q", html.</div></div></section></div></main><footer class="bg-black bottom-0 w-100 pa3" role=contentinfo><div class="flex justify-between"><a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href=/>&copy; Lambda 2022</a><div><div class=ananke-socials></div></div></div></footer></body></html>