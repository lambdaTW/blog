<!doctype html><html lang=en><head><title>Golang :: Lambda</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=/tags/golang/><link rel=stylesheet href=/style.css><link rel="shortcut icon" href=/img/theme-colors/orange.png><link rel=apple-touch-icon href=/img/theme-colors/orange.png><meta name=twitter:card content="summary"><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:title" content="Golang"><meta property="og:description" content><meta property="og:url" content="/tags/golang/"><meta property="og:site_name" content="Lambda"><meta property="og:image" content="img/favicon/%!s().png"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="627"><link href=/tags/golang/index.xml rel=alternate type=application/rss+xml title=Lambda></head><body><div class="container headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=/><div class=logo>Terminal</div></a></div><ul class="menu menu--mobile"><li class=menu__trigger>Menu&nbsp;▾</li><li><ul class=menu__dropdown><li><a href=/>Home</a></li><li><a href=/blog/>Blog</a></li><li><a href=/categories/>Categories</a></li></ul></li></ul></div><nav class=navigation-menu><ul class="navigation-menu__inner menu--desktop"><li><a href=/>Home</a></li><li><a href=/blog/>Blog</a></li><li><a href=/categories/>Categories</a></li></ul></nav></header><div class=content><div class=posts><article class="post on-list"><h1 class=post-title><a href=/blog/grpc/>gRPC</a></h1><div class=post-meta><time class=post-date>2018-11-18 ::</time>
<span class=post-author>lambda@lambda.tw</span></div><span class=post-tags>#<a href=/tags/golang/>golang</a>&nbsp;
#<a href=/tags/grpc/>gRPC</a>&nbsp;</span><div class=post-content>實做一個可以寄信的 gRPC Proto 寫一個寄發信件服務所需要的資料格式 Proto 是一個文件用來儲存 gRPC server 與 client 交換資料時鎖需要的資料格式，建議可以看看它與 JSON 的對照表來迅速了解需要怎樣寫
syntax = "proto3"; // use proto version 3 package pb; // package name /* Add the Send function for use <em>/ service Mail{ rpc Send (MailRequest) returns (MailStatus) {} } /</em> Declare what data you need to let server know and server will use it to send a mail <em>/ message MailRequest{ string from = 1; repeated string to = 2; repeated string cc = 3; string subject = 4; string body = 5; string type = 6; } /</em> Means what the mail status be send or not */ message MailStatus{ int32 status = 1; string code = 2; } 產生 golang 的程式 go get -u github.</div><div><a class="read-more button" href=/blog/grpc/>→</a></div></article><article class="post on-list"><h1 class=post-title><a href=/blog/golangquicksort/>GolangQuickSort</a></h1><div class=post-meta><time class=post-date>2018-08-05 ::</time>
<span class=post-author>lambda@lambda.tw</span></div><span class=post-tags>#<a href=/tags/golang/>Golang</a>&nbsp;</span><div class=post-content>用 Golang 實做快速排序 (quick sort) 快速排序是很常用的一個排序方法，下方我將會用 Golang 實做同步以及異步的快速排序。
同步 實做 func sort(list []int, center int) (complete []int) { left := []int{} right := []int{} for _, num := range list[:center] { if num &lt;= list[center] { left = append(left, num) } else { right = append(right, num) } } if len(list) > center+1 { for _, num := range list[center+1:] { if num &lt;= list[center] { left = append(left, num) } else { right = append(right, num) } } } if len(left) > 1 { left = sort(left, len(left)/2) } if len(right) > 1 { right = sort(right, len(right)/2) } return append(append(left, list[center]), right.</div><div><a class="read-more button" href=/blog/golangquicksort/>→</a></div></article><article class="post on-list"><h1 class=post-title><a href=/blog/golanghttphandler/>GolangHTTPHandler</a></h1><div class=post-meta><time class=post-date>2018-07-21 ::</time>
<span class=post-author>lambda@lambda.tw</span></div><span class=post-tags>#<a href=/tags/golang/>Golang</a>&nbsp;
#<a href=/tags/http/>HTTP</a>&nbsp;</span><div class=post-content>簡易復刻出的 Golang HTTP HandleFunc 身為一個 web 狗，用新語言寫個 router 也是應該的，Golang 本身在寫 HTTP 服務就有極大的優勢，官方自帶的 library 就很好用了，以至於到目前為止的統計大部分的人還是直接使用原生的 library 而非使用框架，但是 router 這部份就統計看來已經有了大方向， Mux 是目前大多數人使用的 router 框架，這邊我們玩一下 Golang 原生的 handler 讓它可以和原生的 HandleFunc 有一樣的感覺
第一步：寫一個簡單的 HTTP server 相信大家都不會。。。當然就是要 google
關鍵字 ： golang http
第一篇就會看到官方的 library 的連結囉！
開一個新專案 cd $GOPATH/src/ mkdir router touch main.go 依照官方網站的提示寫出一個簡單的 HTTP 服務 package main import ( "fmt" "net/http" "html" "log" ) func main() { http.HandleFunc("/bar", func(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, "Hello, %q", html.</div><div><a class="read-more button" href=/blog/golanghttphandler/>→</a></div></article><div class=pagination><div class=pagination__buttons><span class="button next"><a href=/tags/golang/page/2/><span class=button__text>Older posts</span>
<span class=button__icon>→</span></a></span></div></div></div></div><footer class=footer><div class=footer__inner><div class=copyright><span>© 2022 Powered by <a href=http://gohugo.io>Hugo</a></span>
<span>:: Theme made by <a href=https://twitter.com/panr>panr</a></span></div></div></footer><script type=text/javascript src=/bundle.min.js></script></div></body></html>