<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>django on Lambda</title><link>/tags/django/</link><description>Recent content in django on Lambda</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 25 Jan 2020 00:00:00 +0000</lastBuildDate><atom:link href="/tags/django/index.xml" rel="self" type="application/rss+xml"/><item><title>How to fix no route found error on Django Channels</title><link>/blog/how-to-fix-no-route-found-error-on-django-channels/</link><pubDate>Sat, 25 Jan 2020 00:00:00 +0000</pubDate><guid>/blog/how-to-fix-no-route-found-error-on-django-channels/</guid><description>Issue description Django Channels 對於不存在的路徑存取，全部會拋出錯誤，而不是一般性的警告處理，所以如果和我一樣在 Djangoo Channels 有裝上 Sentry ，而且伺服器在被惡意嘗試路徑時就會看到一堆 ValueError: No route found for path '...'. 的錯誤資訊，好處是知道被打了，壞處就是會噴錢（如果不是自己 Hosting）。
Fix it Make HandleRouteNotFoundMiddleware for this issue from datetime import datetime from logging import getLogger from django.urls.exceptions import Resolver404 logger = getLogger(__file__) class HandleRouteNotFoundMiddleware: def __init__(self, inner): self.inner = inner def __call__(self, scope): try: inner_instance = self.inner(scope) return inner_instance except (Resolver404, ValueError) as e: if &amp;#39;No route found for path&amp;#39; not in str(e) and \ scope[&amp;#34;type&amp;#34;] not in [&amp;#39;http&amp;#39;, &amp;#39;websocket&amp;#39;]: raise e logger.</description></item><item><title>Create a GIN index with Django on AWS RDS</title><link>/blog/create-a-gin-index-with-django-on-aws-rds/</link><pubDate>Fri, 26 Apr 2019 00:00:00 +0000</pubDate><guid>/blog/create-a-gin-index-with-django-on-aws-rds/</guid><description>GIN What is it GIN 是一種 INDEX 可以幫助加速全文搜索的速度
GIN stands for Generalized Inverted Index. GIN is designed for handling cases where the items to be indexed are composite values, and the queries to be handled by the index need to search for element values that appear within the composite items. For example, the items could be documents, and the queries could be searches for documents containing specific words.
Normal SQL 在傳統 SQL 下可以用以下幾個步驟完成建立 GIN INDEX</description></item><item><title>Closure</title><link>/blog/closure/</link><pubDate>Thu, 18 Apr 2019 00:00:00 +0000</pubDate><guid>/blog/closure/</guid><description>Closure What is closure Closure 簡單來說，就是某函數在另一個函數內被創造並且參照了創建函數的某些變數，此時該變數會存留於記憶內，儘管創建函數已經結束。
First time meet to Closure N年前在學習 Common Lisp 時教學內出現了一個陌生又奇特的技巧，Closure，以下是他的實做
(let ((counter 0)) (defun reset () (setf counter 0)) (defun stamp () (setf counter (+ counter 1)))) (list (stamp) (stamp) (reset) (stamp)) ; (1 2 0 1) 為了怕正常人看不懂，以下用 Python 翻譯
def gen_counter(): counter = 0 def reset(): nonlocal counter counter = 0 return counter def stamp(): nonlocal counter counter += 1 return counter return reset, stamp reset, stamp = gen_counter() print(stamp()) # 1 print(stamp()) # 2 print(reset()) # 0 print(stamp()) # 1 可以看出在 gen_counter 內的 兩個函數 (reset, stamp) 一同共用內部變數 counter 儘管 gen_counter 已經回傳並且結束，但是在之後的程式卻還是擁有當初初始化的 count，亦即 counter 在記憶體中不會因為 gen_counter 已經回傳就被回收。</description></item></channel></rss>