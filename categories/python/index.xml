<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>python on Lambda</title><link>/categories/python/</link><description>Recent content in python on Lambda</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 27 Apr 2021 00:00:00 +0000</lastBuildDate><atom:link href="/categories/python/index.xml" rel="self" type="application/rss+xml"/><item><title>Python Project (5) Make Automatically</title><link>/blog/python-project-5/</link><pubDate>Tue, 27 Apr 2021 00:00:00 +0000</pubDate><guid>/blog/python-project-5/</guid><description>Makefile Makefile 是個很古老的東西，可以把很多東西自動化，以前用來 compile 需要編譯的語言，但是做為自動化的語意，是十分優雅的，這邊我們把之前有用到的套件，利用 Makefile 將他自動化
Usage make &amp;lt;target&amp;gt; Configuration PKG_FILES := $(shell ls requirements/*.txt) build: ## Build this project as pip wheel rm -rf dist/* python setup.py bdist_wheel .PHONY: build dev-install: build ## Install current code into venv pip install -U dist/*.whl pip: ## Recompile and install all pip packages pip-compile requirements/base.in pip-compile --generate-hashes requirements/development.in pip-compile --generate-hashes requirements/deployment.in pip-sync $(PKG_FILES) .PHONY: pip test: dev-install ## Run test only pytest tests .</description></item><item><title>Python Project (4) Test More</title><link>/blog/python-project-4/</link><pubDate>Sun, 25 Apr 2021 00:00:00 +0000</pubDate><guid>/blog/python-project-4/</guid><description>Python Version Tests 如果專案只是一般服務，可能基本測試就足夠了，但是如果是要寫 Library 給別的專案或是開放給大家使用的話，就要考慮更多的相容性問題，例如： Python 版本，相依套件版本，等等，那一般的測試可能就不足以符合這樣的情境，因此我們需要更多的整合測試
tox 利用 tox 可以測試多種環境，如下圖： 他可以支援 .tox 和 pyproject.toml 但是在 pyproject.toml 裡面是用字串寫舊有設定格式，由於他會先把你的專案，用 setup.py 建立好，用 pip 裝起來後再去執行測試（指令），所以我們要把測試改寫到 tests ，並且儘量用絕對路徑去 import 我們自己的專案，這樣才不會有問題
Usage pip install tox tox -e py38-django31 py38-django31 inst-nodeps: /Users/super/project/prj/.tox/.tmp/package/1/prj-0.1.0.tar.gz py38-django31 installed: asgiref==3.3.4,attrs==20.3.0,coverage==5.5,Django==3.1.8,django-object-actions==3.0.2,prj @ file:///Users/super/project/prj/.tox/.tmp/package/1/prj-0.1.0.tar.gz,iniconfig==1.1.1,packaging==20.9,pluggy==0.13.1,ply==3.11,py==1.10.0,pyparsing==2.4.7,pytest==6.2.3,pytest-cov==2.11.1,pytest-django==4.2.0,python-dateutil==2.8.1,pytz==2021.1,rule-engine==3.2.0,six==1.15.0,sqlparse==0.4.1,toml==0.10.2 py38-django31 run-test-pre: PYTHONHASHSEED='3217434528' py38-django31 run-test: commands[0] | coverage erase py38-django31 run-test: commands[1] | pytest tests ============================= test session starts ============================== platform darwin -- Python 3.8.5, pytest-6.2.3, py-1.10.0, pluggy-0.13.1 -- /Users/super/project/prj/.</description></item><item><title>Python Project (3) Test Your Project</title><link>/blog/python-project-3/</link><pubDate>Sat, 24 Apr 2021 00:00:00 +0000</pubDate><guid>/blog/python-project-3/</guid><description>Test 寫測試可以減少改壞以前的東西，加速開發，在原生的 Python 就有提供測試的方法 unittest，然而隨著越來越多的套件支援與其脫鉤，如果是開新專案，可以試著從一開始就使用 pytest
Pytest 該套件支援簡單的測試方法，多個套件支援其測試，例如在寫 Django Channels 時異步測試就推薦使用 pytest 可以支援其異步測試，該套件也支援 pyproject.toml 當作設定檔
Usage pip install pytest pytest tests =================================================== test session starts =================================================== platform darwin -- Python 3.8.5, pytest-6.2.3, py-1.10.0, pluggy-0.13.1 -- /Users/super/project/prj/venv/bin/python3 cachedir: .pytest_cache django: settings: settings (from ini) rootdir: /Users/super/project/prj, configfile: pyproject.toml plugins: cov-2.11.1, django-4.1.0 collected 26 items Creating test database for alias 'default'... tests/test_admin/test_actions.py::TestCreateTransformationAction::test_transformation_action_check_fk_values PASSED tests/test_models/test_copy.py::TestInnerCopy::test_copy_to_new_diagram_inner_attr_are_copied PASSED tests/test_models/test_copy.py::TestInnerCopy::test_copy_to_new_diagram_nodes_will_be_copied PASSED tests/test_models/test_copy.py::TestInnerCopy::test_copy_to_new_diagram_transitions_will_be_copied PASSED tests/test_models/test_copy.py::TestDeepCopy::test_copy_to_new_diagram_inner_attr_are_copied PASSED tests/test_models/test_copy.py::TestDeepCopy::test_copy_to_new_diagram_nodes_will_be_copied PASSED tests/test_models/test_copy.</description></item><item><title>Python Project (2) Lint Your Project</title><link>/blog/python-project-2/</link><pubDate>Fri, 23 Apr 2021 00:00:00 +0000</pubDate><guid>/blog/python-project-2/</guid><description>Lint 程式寫出來不難，但是要寫的好看很難很難，在多人協作時就需要一個標準，讓大家可以寫起來差不多，Python 給出了 PEP (Python Enhancement Proposals) 8 Style Guide for Python Code 當然正常人不會去看完，所以有工具幫忙就很重要了，這邊介紹 falke8, black, isort 等，工具，方便統一 Coding Style
Flake8 Flake8 可以檢查專案是否符合 PEP 8 ，然而，該檢查有些過時或是有些規範是相互違反的，這部分就有待團隊自行去規定，此時就需要設定他，Flake8 支援 setup.cfg, tox.ini, 或 .flake8 檔，作為設定，此處為了減少檔案，我們使用上次使用到的 setup.cfg 作為我們的設定檔
Usage 裝好該指令後就可以對你的專案進行檢查
pip3 install flake8 flake8 Max Line Length PEP 8 最常被調整的設定就是其每一行程式碼不可超過的字數，該設定原本為每一行不可以超過 79 字元，其由來是以前的 Terminal 長度為 80 字元，為了不讓他換行，所以建議使用該設定，但是現在螢幕都很寬，所以我們可以與團隊溝通調整最大長度
# setup.cfg [flake8] max-line-length = 88 Exclude 某些檔案可能是由機器自動產生的，你不希望被納入控管，可以使用 exclude 的設定讓他跳過該檔案或目錄，這邊以 Django 的 migration file (機器產生)，以及常見虛擬環境目錄 (他人專案) 作為範例
#setup.cfg [flake8] exclude = */migrations/,env/,venv/ Ignore 在 PEP 8 中不少警告是對立的，如：W503、W504，他們的 Best practice 剛好是對方的 Anti-pattern 團隊們可以選擇對於團隊而言比較好的選項，此時我們就可以忽略該筆檢查</description></item><item><title>Python Project (1) setup.py setup.cfg</title><link>/blog/python-project-1/</link><pubDate>Thu, 22 Apr 2021 00:00:00 +0000</pubDate><guid>/blog/python-project-1/</guid><description>Create Project 開專案一直以來都不是一個簡單的事情，專案開的好可以讓後面的開發更有效率，團隊也可以有比較一致開發準則，接下來幾篇文章會大該說說之前研究開 Python 專案的一些經驗
Create setup.py For Install 如果專案要可以被安裝，就需要寫這檔案，裡面可寫詳述該套件需要裝哪些東西，以及一些資訊，建議放在專案的根目錄，這樣別人就可以直接用你的 Git Repo 去安裝你的套件
from pathlib import Path from setuptools import find_packages, setup REPO_URL = &amp;#34;https://github.com/lambdaTW/python-project&amp;#34; def get_version(rel_path): for line in Path(rel_path).open().read().splitlines(): if line.startswith(&amp;#34;__version__&amp;#34;): delim = &amp;#39;&amp;#34;&amp;#39; if &amp;#39;&amp;#34;&amp;#39; in line else &amp;#34;&amp;#39;&amp;#34; return line.split(delim)[1] raise RuntimeError(&amp;#34;Unable to find version string.&amp;#34;) setup( name=&amp;#34;python-project&amp;#34;, version=get_version(&amp;#34;src/python-project/__init__.py&amp;#34;), description=&amp;#34;My python project&amp;#34;, long_description=Path(&amp;#34;README.md&amp;#34;).open().read(), long_description_content_type=&amp;#34;text/markdown&amp;#34;, python_requires=&amp;#34;&amp;gt;=3.8&amp;#34;, classifiers=[ &amp;#34;Programming Language :: Python :: 3.8&amp;#34;, ], keywords=[&amp;#34;python&amp;#34;, &amp;#34;project&amp;#34;], url=REPO_URL, author=&amp;#34;lambdaTW&amp;#34;, author_email=&amp;#34;lambda@lambda.</description></item><item><title>Closure</title><link>/blog/closure/</link><pubDate>Thu, 18 Apr 2019 00:00:00 +0000</pubDate><guid>/blog/closure/</guid><description>Closure What is closure Closure 簡單來說，就是某函數在另一個函數內被創造並且參照了創建函數的某些變數，此時該變數會存留於記憶內，儘管創建函數已經結束。
First time meet to Closure N年前在學習 Common Lisp 時教學內出現了一個陌生又奇特的技巧，Closure，以下是他的實做
(let ((counter 0)) (defun reset () (setf counter 0)) (defun stamp () (setf counter (+ counter 1)))) (list (stamp) (stamp) (reset) (stamp)) ; (1 2 0 1) 為了怕正常人看不懂，以下用 Python 翻譯
def gen_counter(): counter = 0 def reset(): nonlocal counter counter = 0 return counter def stamp(): nonlocal counter counter += 1 return counter return reset, stamp reset, stamp = gen_counter() print(stamp()) # 1 print(stamp()) # 2 print(reset()) # 0 print(stamp()) # 1 可以看出在 gen_counter 內的 兩個函數 (reset, stamp) 一同共用內部變數 counter 儘管 gen_counter 已經回傳並且結束，但是在之後的程式卻還是擁有當初初始化的 count，亦即 counter 在記憶體中不會因為 gen_counter 已經回傳就被回收。</description></item></channel></rss>