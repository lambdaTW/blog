<!doctype html><html lang=en><head><title>Blog :: Lambda</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=/blog/><link rel=stylesheet href=/style.css><link rel="shortcut icon" href=/img/theme-colors/orange.png><link rel=apple-touch-icon href=/img/theme-colors/orange.png><meta name=twitter:card content="summary"><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:title" content="Blog"><meta property="og:description" content><meta property="og:url" content="/blog/"><meta property="og:site_name" content="Lambda"><meta property="og:image" content="img/favicon/%!s().png"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="627"><link href=/blog/index.xml rel=alternate type=application/rss+xml title=Lambda></head><body><div class="container center headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=/><div class=logo>Lambda</div></a></div><ul class="menu menu--mobile"><li class=menu__trigger>Menu&nbsp;▾</li><li><ul class=menu__dropdown><li><a href=/blog/>Blog</a></li><li><a href=/categories/>Categories</a></li><li><a href=/about>About</a></li></ul></li></ul></div><nav class=navigation-menu><ul class="navigation-menu__inner menu--desktop"><li><a href=/blog/>Blog</a></li><li><a href=/categories/>Categories</a></li><li><a href=/about>About</a></li></ul></nav></header><div class=content><div class=posts><article class="post on-list"><h1 class=post-title><a href=/blog/golangquicksort/>GolangQuickSort</a></h1><div class=post-meta><time class=post-date>2018-08-05 ::</time>
<span class=post-author>lambda@lambda.tw</span></div><span class=post-tags>#<a href=/tags/golang/>Golang</a>&nbsp;</span><div class=post-content>用 Golang 實做快速排序 (quick sort) 快速排序是很常用的一個排序方法，下方我將會用 Golang 實做同步以及異步的快速排序。
同步 實做 func sort(list []int, center int) (complete []int) { left := []int{} right := []int{} for _, num := range list[:center] { if num &lt;= list[center] { left = append(left, num) } else { right = append(right, num) } } if len(list) > center+1 { for _, num := range list[center+1:] { if num &lt;= list[center] { left = append(left, num) } else { right = append(right, num) } } } if len(left) > 1 { left = sort(left, len(left)/2) } if len(right) > 1 { right = sort(right, len(right)/2) } return append(append(left, list[center]), right.</div><div><a class="read-more button" href=/blog/golangquicksort/>→</a></div></article><article class="post on-list"><h1 class=post-title><a href=/blog/golanghttphandler/>GolangHTTPHandler</a></h1><div class=post-meta><time class=post-date>2018-07-21 ::</time>
<span class=post-author>lambda@lambda.tw</span></div><span class=post-tags>#<a href=/tags/golang/>Golang</a>&nbsp;
#<a href=/tags/http/>HTTP</a>&nbsp;</span><div class=post-content>簡易復刻出的 Golang HTTP HandleFunc 身為一個 web 狗，用新語言寫個 router 也是應該的，Golang 本身在寫 HTTP 服務就有極大的優勢，官方自帶的 library 就很好用了，以至於到目前為止的統計大部分的人還是直接使用原生的 library 而非使用框架，但是 router 這部份就統計看來已經有了大方向， Mux 是目前大多數人使用的 router 框架，這邊我們玩一下 Golang 原生的 handler 讓它可以和原生的 HandleFunc 有一樣的感覺
第一步：寫一個簡單的 HTTP server 相信大家都不會。。。當然就是要 google
關鍵字 ： golang http
第一篇就會看到官方的 library 的連結囉！
開一個新專案 cd $GOPATH/src/ mkdir router touch main.go 依照官方網站的提示寫出一個簡單的 HTTP 服務 package main import ( "fmt" "net/http" "html" "log" ) func main() { http.HandleFunc("/bar", func(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, "Hello, %q", html.</div><div><a class="read-more button" href=/blog/golanghttphandler/>→</a></div></article><article class="post on-list"><h1 class=post-title><a href=/blog/finderrornumber/>FindErrorNumber</a></h1><div class=post-meta><time class=post-date>2018-07-12 ::</time>
<span class=post-author>lambda@lambda.tw</span></div><span class=post-tags>#<a href=/tags/golang/>Golang</a>&nbsp;</span><div class=post-content>找出錯誤的數字，使用 Golang 題目 在輸入一連串的數字中(從一開始連續[1, 2, 3, 4, 5, 6])找到錯誤(重複)的數字，並且把錯誤的先列出來再將正確的數字附加到到後面
輸入 [1,2,2,4] [1,2,2,4,5,5,7] 輸出 [2,3] [2,5,3,6] 實做 main.go package main import "fmt" func findErrorNums(nums []int) (ret []int) { dict := make(map[int]int) for _, num := range nums { _, ok := dict[num] if ok { ret = append(ret, num) } else { dict[num] = num } } for i := 1; i &lt;= len(nums); i++ { _, ok := dict[i] if !</div><div><a class="read-more button" href=/blog/finderrornumber/>→</a></div></article><div class=pagination><div class=pagination__buttons><span class="button previous"><a href=/blog/page/6/><span class=button__icon>←</span>
<span class=button__text>Newer posts</span></a></span>
<span class="button next"><a href=/blog/page/8/><span class=button__text>Older posts</span>
<span class=button__icon>→</span></a></span></div></div></div></div><footer class=footer><div class=footer__inner><div class=copyright><span>© 2022 Powered by <a href=http://gohugo.io>Hugo</a></span>
<span>:: Theme made by <a href=https://twitter.com/panr>panr</a></span></div></div></footer><script type=text/javascript src=/bundle.min.js></script></div></body></html>