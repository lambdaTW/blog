<!doctype html><html lang=en><head><title>GolangQuickSort :: Lambda</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="用 Golang 實做快速排序 (quick sort) 快速排序是很常用的一個排序方法，下方我將會用 Golang 實做同步以及異步的快速排序。
同步 實做 func sort(list []int, center int) (complete []int) { left := []int{} right := []int{} for _, num := range list[:center] { if num &amp;lt;= list[center] { left = append(left, num) } else { right = append(right, num) } } if len(list) &amp;gt; center+1 { for _, num := range list[center+1:] { if num &amp;lt;= list[center] { left = append(left, num) } else { right = append(right, num) } } } if len(left) &amp;gt; 1 { left = sort(left, len(left)/2) } if len(right) &amp;gt; 1 { right = sort(right, len(right)/2) } return append(append(left, list[center]), right."><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=/blog/golangquicksort/><link rel=stylesheet href=/style.css><link rel="shortcut icon" href=/img/theme-colors/orange.png><link rel=apple-touch-icon href=/img/theme-colors/orange.png><meta name=twitter:card content="summary"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="og:title" content="GolangQuickSort"><meta property="og:description" content="用 Golang 實做快速排序 (quick sort) 快速排序是很常用的一個排序方法，下方我將會用 Golang 實做同步以及異步的快速排序。
同步 實做 func sort(list []int, center int) (complete []int) { left := []int{} right := []int{} for _, num := range list[:center] { if num &amp;lt;= list[center] { left = append(left, num) } else { right = append(right, num) } } if len(list) &amp;gt; center+1 { for _, num := range list[center+1:] { if num &amp;lt;= list[center] { left = append(left, num) } else { right = append(right, num) } } } if len(left) &amp;gt; 1 { left = sort(left, len(left)/2) } if len(right) &amp;gt; 1 { right = sort(right, len(right)/2) } return append(append(left, list[center]), right."><meta property="og:url" content="/blog/golangquicksort/"><meta property="og:site_name" content="Lambda"><meta property="og:image" content="img/favicon/%!s().png"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="627"><meta property="article:section" content="Golang"><meta property="article:published_time" content="2018-08-05 00:00:00 +0000 UTC"></head><body><div class="container center headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=/><div class=logo>Lambda</div></a></div><ul class="menu menu--mobile"><li class=menu__trigger>Menu&nbsp;▾</li><li><ul class=menu__dropdown><li><a href=/blog/>Blog</a></li><li><a href=/categories/>Categories</a></li><li><a href=/about>About</a></li></ul></li></ul></div><nav class=navigation-menu><ul class="navigation-menu__inner menu--desktop"><li><a href=/blog/>Blog</a></li><li><a href=/categories/>Categories</a></li><li><a href=/about>About</a></li></ul></nav></header><div class=content><article class=post><h1 class=post-title><a href=/blog/golangquicksort/>GolangQuickSort</a></h1><div class=post-meta><time class=post-date>2018-08-05 ::</time>
<span class=post-author>lambda@lambda.tw</span></div><span class=post-tags>#<a href=/tags/golang/>Golang</a>&nbsp;</span><div class=post-content><div><h1 id=用-golang-實做快速排序-quick-sort>用 Golang 實做快速排序 (quick sort)<a href=#用-golang-實做快速排序-quick-sort class=hanchor arialabel=Anchor>&#8983;</a></h1><p>快速排序是很常用的一個排序方法，下方我將會用 Golang 實做同步以及異步的快速排序。</p><h2 id=同步>同步<a href=#同步 class=hanchor arialabel=Anchor>&#8983;</a></h2><h3 id=實做>實做<a href=#實做 class=hanchor arialabel=Anchor>&#8983;</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>sort</span>(<span style=color:#a6e22e>list</span> []<span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>center</span> <span style=color:#66d9ef>int</span>) (<span style=color:#a6e22e>complete</span> []<span style=color:#66d9ef>int</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>left</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>int</span>{}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>right</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>int</span>{}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>num</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>list</span>[:<span style=color:#a6e22e>center</span>] {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>num</span> <span style=color:#f92672>&lt;=</span> <span style=color:#a6e22e>list</span>[<span style=color:#a6e22e>center</span>] {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>left</span> = append(<span style=color:#a6e22e>left</span>, <span style=color:#a6e22e>num</span>)
</span></span><span style=display:flex><span>		} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>right</span> = append(<span style=color:#a6e22e>right</span>, <span style=color:#a6e22e>num</span>)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> len(<span style=color:#a6e22e>list</span>) &gt; <span style=color:#a6e22e>center</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>num</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>list</span>[<span style=color:#a6e22e>center</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>:] {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>num</span> <span style=color:#f92672>&lt;=</span> <span style=color:#a6e22e>list</span>[<span style=color:#a6e22e>center</span>] {
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>left</span> = append(<span style=color:#a6e22e>left</span>, <span style=color:#a6e22e>num</span>)
</span></span><span style=display:flex><span>			} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>right</span> = append(<span style=color:#a6e22e>right</span>, <span style=color:#a6e22e>num</span>)
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> len(<span style=color:#a6e22e>left</span>) &gt; <span style=color:#ae81ff>1</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>left</span> = <span style=color:#a6e22e>sort</span>(<span style=color:#a6e22e>left</span>, len(<span style=color:#a6e22e>left</span>)<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> len(<span style=color:#a6e22e>right</span>) &gt; <span style=color:#ae81ff>1</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>right</span> = <span style=color:#a6e22e>sort</span>(<span style=color:#a6e22e>right</span>, len(<span style=color:#a6e22e>right</span>)<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> append(append(<span style=color:#a6e22e>left</span>, <span style=color:#a6e22e>list</span>[<span style=color:#a6e22e>center</span>]), <span style=color:#a6e22e>right</span><span style=color:#f92672>...</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=異步>異步<a href=#異步 class=hanchor arialabel=Anchor>&#8983;</a></h2><h3 id=go>go<a href=#go class=hanchor arialabel=Anchor>&#8983;</a></h3><p>Golang 強大的異步使用 goroutine 讓寫異步程式如喝水般簡單，go 不同於其他語言使用 thread 或是 process (fork) 之類的的方法，他在底層運用自己強大的 go scheduler 讓每個異步程序可以在作業系統可用執行緒改變下，依然可以執行你所要跑得程序。<img src=http://jolestar.com/images/concurrent/go-scheduler.png alt=go-scheduler></p><h4 id=實做-1>實做<a href=#實做-1 class=hanchor arialabel=Anchor>&#8983;</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>go</span> <span style=color:#66d9ef>func</span>() {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;time need&#34;</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>執行指令 <code>go run main.go</code> 你會發現沒東西，因為它將無名 function 放到背景後程式就結束了，為了要可以看到我們要 print 的東西我們讓它睡覺一下。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;time&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>go</span> <span style=color:#66d9ef>func</span>() {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;You can see me.&#34;</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Sleep</span>(<span style=color:#ae81ff>100</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Millisecond</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>此時再次執行 <code>go run main.go</code> 你會發現可以看到我們要輸出的字串了！</p><h4 id=為什麼>為什麼？<a href=#為什麼 class=hanchor arialabel=Anchor>&#8983;</a></h4><pre tabindex=0><code># 原本沒有等待的程式
--&gt; main.go --&gt; go func --&gt; end
						goroutine wait --&gt; 主程式結束所以沒有 print
# 等待的程式
--&gt; main.go --&gt; go func --&gt; wait...............................--&gt; end -- 在 go func 跑完 Sleep 後才結束
						goroutine wait --&gt; print
</code></pre><h4 id=channel>channel<a href=#channel class=hanchor arialabel=Anchor>&#8983;</a></h4><p>Golang 在 goroutine 中所使用的溝通媒介，類似其他語言多 threading 使用全域的 Queue</p><h5 id=實做-2>實做<a href=#實做-2 class=hanchor arialabel=Anchor>&#8983;</a></h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>c</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>int</span>)
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 在背景執行 把 100 丟到 c 裡面
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>go</span> <span style=color:#66d9ef>func</span>() {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>c</span> <span style=color:#f92672>&lt;-</span> <span style=color:#ae81ff>100</span>
</span></span><span style=display:flex><span>	}()
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 從 c 裡面拿值，此處會等待 c 有值為止才會執行
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>Print</span>(<span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>c</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=速度比較>速度比較<a href=#速度比較 class=hanchor arialabel=Anchor>&#8983;</a></h2><h3 id=golang-的測試>Golang 的測試<a href=#golang-的測試 class=hanchor arialabel=Anchor>&#8983;</a></h3><p>在 Golang 寫測試很簡單只需要在同一目錄中使用相同 package ，並且檔案名稱以 _test.go 結尾，並且把要測試的程式接收依照特殊的參數以及命名即可</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// 跑 test，以 Test 當作 function 開頭並接收 (t *testing.T) 參數
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>TestSomeThing</span>(<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>testing</span>.<span style=color:#a6e22e>T</span>) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>// 跑 benchmark，以 Benchmark 當作 function 開頭並接收 (t *testing.B) 參數
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>BenchmarkSomeThing</span>(<span style=color:#a6e22e>t</span> <span style=color:#a6e22e>testing</span>.<span style=color:#f92672>*</span><span style=color:#a6e22e>B</span>) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=建立測試檔案>建立測試檔案<a href=#建立測試檔案 class=hanchor arialabel=Anchor>&#8983;</a></h4><pre tabindex=0><code class=language-shell-script data-lang=shell-script>touch $GOPATH/project/sort_test.go
code $GOPATH/project/sort_test.go
</code></pre><h4 id=實做-3>實做<a href=#實做-3 class=hanchor arialabel=Anchor>&#8983;</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;testing&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>needSort</span> = []<span style=color:#66d9ef>int</span>{}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>init</span>() {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#ae81ff>1000000</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>needSort</span> = append(<span style=color:#a6e22e>needSort</span>, <span style=color:#a6e22e>rand</span>.<span style=color:#a6e22e>Intn</span>(<span style=color:#ae81ff>1000000</span>))
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>BenchmarkSync</span>(<span style=color:#a6e22e>b</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>testing</span>.<span style=color:#a6e22e>B</span>) {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// fmt.Println(&#34;call BenchmarkSync&#34;, len(needSort))
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>sort</span>(<span style=color:#a6e22e>needSort</span>, len(<span style=color:#a6e22e>needSort</span>)<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>BenchmarkAsync</span>(<span style=color:#a6e22e>b</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>testing</span>.<span style=color:#a6e22e>B</span>) {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// fmt.Println(&#34;call BenchmarkAsync&#34;, len(needSort))
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>cmp</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>int</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>go</span> <span style=color:#a6e22e>goSort</span>(<span style=color:#a6e22e>needSort</span>, int(len(<span style=color:#a6e22e>needSort</span>)<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span>), <span style=color:#a6e22e>cmp</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; len(<span style=color:#a6e22e>needSort</span>); <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>		<span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>cmp</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=跑測試>跑測試<a href=#跑測試 class=hanchor arialabel=Anchor>&#8983;</a></h4><h5 id=執行>執行<a href=#執行 class=hanchor arialabel=Anchor>&#8983;</a></h5><pre tabindex=0><code class=language-shell-script data-lang=shell-script>go test -bench=.
</code></pre><h5 id=輸出>輸出<a href=#輸出 class=hanchor arialabel=Anchor>&#8983;</a></h5><p>最後可以看到同步的程式 go test 幫我們跑了 2000000000 次，平均每次只要跑 0.24 ns，相較於非同步程式，跑一次就要花 6650871377 ns 快上非常多</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>goos: linux
</span></span><span style=display:flex><span>goarch: amd64
</span></span><span style=display:flex><span>pkg: gosort
</span></span><span style=display:flex><span>BenchmarkSync-4		2000000000	0.24 ns/op
</span></span><span style=display:flex><span>BenchmarkAsync-4	1		6650871377 ns/op
</span></span><span style=display:flex><span>PASS
</span></span><span style=display:flex><span>ok  	gosort	15.644s
</span></span><span style=display:flex><span>go test -bench=.  27.97s user 1.55s system 185% cpu 15.910 total
</span></span></code></pre></div><h2 id=結論>結論<a href=#結論 class=hanchor arialabel=Anchor>&#8983;</a></h2><p>非同步的程式需要等待 go routing 幫它開啟一些東西，就速度上不一定會比較快，它的好處當然就是不用等它跑完，也可以分多個線程下去加快速度，但是如果沒有優化好就會像上面的程式一樣慢慢的。</p></div></div><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//blog-khfo0axv59.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></article></div><footer class=footer><div class=footer__inner><div class=copyright><span>© 2023 Powered by <a href=http://gohugo.io>Hugo</a></span>
<span>:: Theme made by <a href=https://twitter.com/panr>panr</a></span></div></div></footer><script type=text/javascript src=/bundle.min.js></script></div></body></html>