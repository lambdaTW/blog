<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>GolangQuickSort | Lambda</title><meta name=viewport content="width=device-width,minimum-scale=1"><meta name=description content="用 Golang 實做快速排序 (quick sort) 快速排序是很常用的一個排序方法，下方我將會用 Golang 實做同步以及異步的快速排序。
同步 實做 func sort(list []int, center int) (complete []int) { left := []int{} right := []int{} for _, num := range list[:center] { if num <= list[center] { left = append(left, num) } else { right = append(right, num) } } if len(list) > center+1 { for _, num := range list[center+1:] { if num <= list[center] { left = append(left, num) } else { right = append(right, num) } } } if len(left) > 1 { left = sort(left, len(left)/2) } if len(right) > 1 { right = sort(right, len(right)/2) } return append(append(left, list[center]), right."><meta name=generator content="Hugo 0.105.0"><meta name=robots content="noindex, nofollow"><link rel=stylesheet href=/ananke/css/main.min.css><meta property="og:title" content="GolangQuickSort"><meta property="og:description" content="用 Golang 實做快速排序 (quick sort) 快速排序是很常用的一個排序方法，下方我將會用 Golang 實做同步以及異步的快速排序。
同步 實做 func sort(list []int, center int) (complete []int) { left := []int{} right := []int{} for _, num := range list[:center] { if num <= list[center] { left = append(left, num) } else { right = append(right, num) } } if len(list) > center+1 { for _, num := range list[center+1:] { if num <= list[center] { left = append(left, num) } else { right = append(right, num) } } } if len(left) > 1 { left = sort(left, len(left)/2) } if len(right) > 1 { right = sort(right, len(right)/2) } return append(append(left, list[center]), right."><meta property="og:type" content="article"><meta property="og:url" content="/blog/golangquicksort/"><meta property="article:section" content="blog"><meta property="article:published_time" content="2018-08-05T00:00:00+00:00"><meta property="article:modified_time" content="2018-08-05T00:00:00+00:00"><meta itemprop=name content="GolangQuickSort"><meta itemprop=description content="用 Golang 實做快速排序 (quick sort) 快速排序是很常用的一個排序方法，下方我將會用 Golang 實做同步以及異步的快速排序。
同步 實做 func sort(list []int, center int) (complete []int) { left := []int{} right := []int{} for _, num := range list[:center] { if num <= list[center] { left = append(left, num) } else { right = append(right, num) } } if len(list) > center+1 { for _, num := range list[center+1:] { if num <= list[center] { left = append(left, num) } else { right = append(right, num) } } } if len(left) > 1 { left = sort(left, len(left)/2) } if len(right) > 1 { right = sort(right, len(right)/2) } return append(append(left, list[center]), right."><meta itemprop=datePublished content="2018-08-05T00:00:00+00:00"><meta itemprop=dateModified content="2018-08-05T00:00:00+00:00"><meta itemprop=wordCount content="414"><meta itemprop=keywords content="Golang,"><meta name=twitter:card content="summary"><meta name=twitter:title content="GolangQuickSort"><meta name=twitter:description content="用 Golang 實做快速排序 (quick sort) 快速排序是很常用的一個排序方法，下方我將會用 Golang 實做同步以及異步的快速排序。
同步 實做 func sort(list []int, center int) (complete []int) { left := []int{} right := []int{} for _, num := range list[:center] { if num <= list[center] { left = append(left, num) } else { right = append(right, num) } } if len(list) > center+1 { for _, num := range list[center+1:] { if num <= list[center] { left = append(left, num) } else { right = append(right, num) } } } if len(left) > 1 { left = sort(left, len(left)/2) } if len(right) > 1 { right = sort(right, len(right)/2) } return append(append(left, list[center]), right."></head><body class="ma0 avenir bg-near-white"><header><div class=bg-black><nav class="pv3 ph3 ph4-ns" role=navigation><div class="flex-l justify-between items-center center"><a href=/ class="f3 fw2 hover-white no-underline white-90 dib">Lambda</a><div class="flex-l items-center"><ul class="pl0 mr3"><li class="list f5 f4-ns fw4 dib pr3"><a class="hover-white no-underline white-90" href=/ title="Home page">Home</a></li><li class="list f5 f4-ns fw4 dib pr3"><a class="hover-white no-underline white-90" href=/blog/ title="Blog page">Blog</a></li><li class="list f5 f4-ns fw4 dib pr3"><a class="hover-white no-underline white-90" href=/categories/ title="Categories page">Categories</a></li></ul><div class=ananke-socials></div></div></div></nav></div></header><main class=pb7 role=main><article class="flex-l flex-wrap justify-between mw8 center ph3"><header class="mt4 w-100"><aside class="instapaper_ignoref b helvetica tracked">BLOG</aside><div id=sharing class="mt3 ananke-socials"></div><h1 class="f1 athelas mt3 mb1">GolangQuickSort</h1><p class=tracked>By <strong><a href=mailto:lambda@lambda.tw>lambda@lambda.tw</a></strong></p><time class="f6 mv4 dib tracked" datetime=2018-08-05T00:00:00Z>August 5, 2018</time></header><div class="nested-copy-line-height lh-copy serif f4 nested-links mid-gray pr4-l w-two-thirds-l"><h1 id=用-golang-實做快速排序-quick-sort>用 Golang 實做快速排序 (quick sort)</h1><p>快速排序是很常用的一個排序方法，下方我將會用 Golang 實做同步以及異步的快速排序。</p><h2 id=同步>同步</h2><h3 id=實做>實做</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>sort</span>(<span style=color:#a6e22e>list</span> []<span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>center</span> <span style=color:#66d9ef>int</span>) (<span style=color:#a6e22e>complete</span> []<span style=color:#66d9ef>int</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>left</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>int</span>{}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>right</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>int</span>{}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>num</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>list</span>[:<span style=color:#a6e22e>center</span>] {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>num</span> <span style=color:#f92672>&lt;=</span> <span style=color:#a6e22e>list</span>[<span style=color:#a6e22e>center</span>] {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>left</span> = append(<span style=color:#a6e22e>left</span>, <span style=color:#a6e22e>num</span>)
</span></span><span style=display:flex><span>		} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>right</span> = append(<span style=color:#a6e22e>right</span>, <span style=color:#a6e22e>num</span>)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> len(<span style=color:#a6e22e>list</span>) &gt; <span style=color:#a6e22e>center</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>num</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>list</span>[<span style=color:#a6e22e>center</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>:] {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>num</span> <span style=color:#f92672>&lt;=</span> <span style=color:#a6e22e>list</span>[<span style=color:#a6e22e>center</span>] {
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>left</span> = append(<span style=color:#a6e22e>left</span>, <span style=color:#a6e22e>num</span>)
</span></span><span style=display:flex><span>			} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>right</span> = append(<span style=color:#a6e22e>right</span>, <span style=color:#a6e22e>num</span>)
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> len(<span style=color:#a6e22e>left</span>) &gt; <span style=color:#ae81ff>1</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>left</span> = <span style=color:#a6e22e>sort</span>(<span style=color:#a6e22e>left</span>, len(<span style=color:#a6e22e>left</span>)<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> len(<span style=color:#a6e22e>right</span>) &gt; <span style=color:#ae81ff>1</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>right</span> = <span style=color:#a6e22e>sort</span>(<span style=color:#a6e22e>right</span>, len(<span style=color:#a6e22e>right</span>)<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> append(append(<span style=color:#a6e22e>left</span>, <span style=color:#a6e22e>list</span>[<span style=color:#a6e22e>center</span>]), <span style=color:#a6e22e>right</span><span style=color:#f92672>...</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=異步>異步</h2><h3 id=go>go</h3><p>Golang 強大的異步使用 goroutine 讓寫異步程式如喝水般簡單，go 不同於其他語言使用 thread 或是 process (fork) 之類的的方法，他在底層運用自己強大的 go scheduler 讓每個異步程序可以在作業系統可用執行緒改變下，依然可以執行你所要跑得程序。<img src=http://jolestar.com/images/concurrent/go-scheduler.png alt=go-scheduler></p><h4 id=實做-1>實做</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>go</span> <span style=color:#66d9ef>func</span>() {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;time need&#34;</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>執行指令 <code>go run main.go</code> 你會發現沒東西，因為它將無名 function 放到背景後程式就結束了，為了要可以看到我們要 print 的東西我們讓它睡覺一下。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;time&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>go</span> <span style=color:#66d9ef>func</span>() {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;You can see me.&#34;</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Sleep</span>(<span style=color:#ae81ff>100</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Millisecond</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>此時再次執行 <code>go run main.go</code> 你會發現可以看到我們要輸出的字串了！</p><h4 id=為什麼>為什麼？</h4><pre tabindex=0><code># 原本沒有等待的程式
--&gt; main.go --&gt; go func --&gt; end
						goroutine wait --&gt; 主程式結束所以沒有 print
# 等待的程式
--&gt; main.go --&gt; go func --&gt; wait...............................--&gt; end -- 在 go func 跑完 Sleep 後才結束
						goroutine wait --&gt; print
</code></pre><h4 id=channel>channel</h4><p>Golang 在 goroutine 中所使用的溝通媒介，類似其他語言多 threading 使用全域的 Queue</p><h5 id=實做-2>實做</h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>c</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>int</span>)
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 在背景執行 把 100 丟到 c 裡面
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>go</span> <span style=color:#66d9ef>func</span>() {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>c</span> <span style=color:#f92672>&lt;-</span> <span style=color:#ae81ff>100</span>
</span></span><span style=display:flex><span>	}()
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 從 c 裡面拿值，此處會等待 c 有值為止才會執行
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>Print</span>(<span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>c</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=速度比較>速度比較</h2><h3 id=golang-的測試>Golang 的測試</h3><p>在 Golang 寫測試很簡單只需要在同一目錄中使用相同 package ，並且檔案名稱以 _test.go 結尾，並且把要測試的程式接收依照特殊的參數以及命名即可</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// 跑 test，以 Test 當作 function 開頭並接收 (t *testing.T) 參數
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>TestSomeThing</span>(<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>testing</span>.<span style=color:#a6e22e>T</span>) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>// 跑 benchmark，以 Benchmark 當作 function 開頭並接收 (t *testing.B) 參數
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>BenchmarkSomeThing</span>(<span style=color:#a6e22e>t</span> <span style=color:#a6e22e>testing</span>.<span style=color:#f92672>*</span><span style=color:#a6e22e>B</span>) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=建立測試檔案>建立測試檔案</h4><pre tabindex=0><code class=language-shell-script data-lang=shell-script>touch $GOPATH/project/sort_test.go
code $GOPATH/project/sort_test.go
</code></pre><h4 id=實做-3>實做</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;testing&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>needSort</span> = []<span style=color:#66d9ef>int</span>{}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>init</span>() {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#ae81ff>1000000</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>needSort</span> = append(<span style=color:#a6e22e>needSort</span>, <span style=color:#a6e22e>rand</span>.<span style=color:#a6e22e>Intn</span>(<span style=color:#ae81ff>1000000</span>))
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>BenchmarkSync</span>(<span style=color:#a6e22e>b</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>testing</span>.<span style=color:#a6e22e>B</span>) {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// fmt.Println(&#34;call BenchmarkSync&#34;, len(needSort))
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>sort</span>(<span style=color:#a6e22e>needSort</span>, len(<span style=color:#a6e22e>needSort</span>)<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>BenchmarkAsync</span>(<span style=color:#a6e22e>b</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>testing</span>.<span style=color:#a6e22e>B</span>) {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// fmt.Println(&#34;call BenchmarkAsync&#34;, len(needSort))
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>cmp</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>int</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>go</span> <span style=color:#a6e22e>goSort</span>(<span style=color:#a6e22e>needSort</span>, int(len(<span style=color:#a6e22e>needSort</span>)<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span>), <span style=color:#a6e22e>cmp</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; len(<span style=color:#a6e22e>needSort</span>); <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>		<span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>cmp</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=跑測試>跑測試</h4><h5 id=執行>執行</h5><pre tabindex=0><code class=language-shell-script data-lang=shell-script>go test -bench=.
</code></pre><h5 id=輸出>輸出</h5><p>最後可以看到同步的程式 go test 幫我們跑了 2000000000 次，平均每次只要跑 0.24 ns，相較於非同步程式，跑一次就要花 6650871377 ns 快上非常多</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>goos: linux
</span></span><span style=display:flex><span>goarch: amd64
</span></span><span style=display:flex><span>pkg: gosort
</span></span><span style=display:flex><span>BenchmarkSync-4		2000000000	0.24 ns/op
</span></span><span style=display:flex><span>BenchmarkAsync-4	1		6650871377 ns/op
</span></span><span style=display:flex><span>PASS
</span></span><span style=display:flex><span>ok  	gosort	15.644s
</span></span><span style=display:flex><span>go test -bench=.  27.97s user 1.55s system 185% cpu 15.910 total
</span></span></code></pre></div><h2 id=結論>結論</h2><p>非同步的程式需要等待 go routing 幫它開啟一些東西，就速度上不一定會比較快，它的好處當然就是不用等它跑完，也可以分多個線程下去加快速度，但是如果沒有優化好就會像上面的程式一樣慢慢的。</p><ul class=pa0><li class="list di"><a href=/tags/golang/ class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">Golang</a></li></ul><div class="mt6 instapaper_ignoref"><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//blog-khfo0axv59.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div></div><aside class="w-30-l mt6-l"><div class="bg-light-gray pa3 nested-list-reset nested-copy-line-height nested-links"><p class="f5 b mb3">Related</p><ul class="pa0 list"><li class=mb2><a href=/blog/golanghttphandler/>GolangHTTPHandler</a></li><li class=mb2><a href=/blog/finderrornumber/>FindErrorNumber</a></li><li class=mb2><a href=/blog/helloworld/>Hello Golang</a></li></ul></div></aside></article></main><footer class="bg-black bottom-0 w-100 pa3" role=contentinfo><div class="flex justify-between"><a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href=/>&copy; Lambda 2022</a><div><div class=ananke-socials></div></div></div></footer></body></html>