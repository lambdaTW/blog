<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Blog on Lambda</title><link>/blog/</link><description>Recent content in Blog on Lambda</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 26 Oct 2022 21:21:46 +0800</lastBuildDate><atom:link href="/blog/index.xml" rel="self" type="application/rss+xml"/><item><title>AWS Architecture Study Buzzdial</title><link>/blog/aws-architecture-study-buzzdial/</link><pubDate>Wed, 26 Oct 2022 21:21:46 +0800</pubDate><guid>/blog/aws-architecture-study-buzzdial/</guid><description>簡介 Buzzdial 是一家製作電視 Live 節目即時互動的公司，可以想像主持人問答，在家中看電視的你也可以使用 App 與其他相同收看電視的人們互相交流，目前已經找不到網站，看起來應該是已經收掉了，但是還是可以找到相關資訊
遇到的問題 當遇某一特殊事件，導致大量使用者在同一時間使用服務時，需要保證網路以及伺服器可以負荷，並且該特殊事件可能不會天天發生，如果使用傳統架構會需要大量的初始建構成本
導入 AWS 的架構 Buzzdial AWS Architecture 架構拆想 可以看到 Buzzdial 使用了兩個分開的 ASG (auto scale group)，一個是做 Web，另一個是做管理的部分
第一次猜想 可以想像，電視製作或是主持人可以透過 API 去發送事件廣播 (broadcast)，讓所有使用者去看到或是被通知有一個互動發生 (例如：新的題目) Web App 中的 Deamon 可以透過 Logging DB 來通知使用者有新的事件 第二次猜想 We queue those records and store them in our databases to allow us to report back to clients on the success of their broadcast event, and also provide detailed business reports that we review internally.</description></item><item><title>Python Project (5) Make Automatically</title><link>/blog/python-project-5/</link><pubDate>Tue, 27 Apr 2021 00:00:00 +0000</pubDate><guid>/blog/python-project-5/</guid><description>Makefile Makefile 是個很古老的東西，可以把很多東西自動化，以前用來 compile 需要編譯的語言，但是做為自動化的語意，是十分優雅的，這邊我們把之前有用到的套件，利用 Makefile 將他自動化
Usage make &amp;lt;target&amp;gt; Configuration PKG_FILES := $(shell ls requirements/*.txt) build: ## Build this project as pip wheel rm -rf dist/* python setup.py bdist_wheel .PHONY: build dev-install: build ## Install current code into venv pip install -U dist/*.whl pip: ## Recompile and install all pip packages pip-compile requirements/base.in pip-compile --generate-hashes requirements/development.in pip-compile --generate-hashes requirements/deployment.in pip-sync $(PKG_FILES) .PHONY: pip test: dev-install ## Run test only pytest tests .</description></item><item><title>Python Project (4) Test More</title><link>/blog/python-project-4/</link><pubDate>Sun, 25 Apr 2021 00:00:00 +0000</pubDate><guid>/blog/python-project-4/</guid><description>Python Version Tests 如果專案只是一般服務，可能基本測試就足夠了，但是如果是要寫 Library 給別的專案或是開放給大家使用的話，就要考慮更多的相容性問題，例如： Python 版本，相依套件版本，等等，那一般的測試可能就不足以符合這樣的情境，因此我們需要更多的整合測試
tox 利用 tox 可以測試多種環境，如下圖： 他可以支援 .tox 和 pyproject.toml 但是在 pyproject.toml 裡面是用字串寫舊有設定格式，由於他會先把你的專案，用 setup.py 建立好，用 pip 裝起來後再去執行測試（指令），所以我們要把測試改寫到 tests ，並且儘量用絕對路徑去 import 我們自己的專案，這樣才不會有問題
Usage pip install tox tox -e py38-django31 py38-django31 inst-nodeps: /Users/super/project/prj/.tox/.tmp/package/1/prj-0.1.0.tar.gz py38-django31 installed: asgiref==3.3.4,attrs==20.3.0,coverage==5.5,Django==3.1.8,django-object-actions==3.0.2,prj @ file:///Users/super/project/prj/.tox/.tmp/package/1/prj-0.1.0.tar.gz,iniconfig==1.1.1,packaging==20.9,pluggy==0.13.1,ply==3.11,py==1.10.0,pyparsing==2.4.7,pytest==6.2.3,pytest-cov==2.11.1,pytest-django==4.2.0,python-dateutil==2.8.1,pytz==2021.1,rule-engine==3.2.0,six==1.15.0,sqlparse==0.4.1,toml==0.10.2 py38-django31 run-test-pre: PYTHONHASHSEED=&amp;#39;3217434528&amp;#39; py38-django31 run-test: commands[0] | coverage erase py38-django31 run-test: commands[1] | pytest tests ============================= test session starts ============================== platform darwin -- Python 3.8.5, pytest-6.2.3, py-1.10.0, pluggy-0.13.1 -- /Users/super/project/prj/.</description></item><item><title>Python Project (3) Test Your Project</title><link>/blog/python-project-3/</link><pubDate>Sat, 24 Apr 2021 00:00:00 +0000</pubDate><guid>/blog/python-project-3/</guid><description>Test 寫測試可以減少改壞以前的東西，加速開發，在原生的 Python 就有提供測試的方法 unittest，然而隨著越來越多的套件支援與其脫鉤，如果是開新專案，可以試著從一開始就使用 pytest
Pytest 該套件支援簡單的測試方法，多個套件支援其測試，例如在寫 Django Channels 時異步測試就推薦使用 pytest 可以支援其異步測試，該套件也支援 pyproject.toml 當作設定檔
Usage pip install pytest pytest tests =================================================== test session starts =================================================== platform darwin -- Python 3.8.5, pytest-6.2.3, py-1.10.0, pluggy-0.13.1 -- /Users/super/project/prj/venv/bin/python3 cachedir: .pytest_cache django: settings: settings (from ini) rootdir: /Users/super/project/prj, configfile: pyproject.toml plugins: cov-2.11.1, django-4.1.0 collected 26 items Creating test database for alias &amp;#39;default&amp;#39;... tests/test_admin/test_actions.py::TestCreateTransformationAction::test_transformation_action_check_fk_values PASSED tests/test_models/test_copy.py::TestInnerCopy::test_copy_to_new_diagram_inner_attr_are_copied PASSED tests/test_models/test_copy.py::TestInnerCopy::test_copy_to_new_diagram_nodes_will_be_copied PASSED tests/test_models/test_copy.py::TestInnerCopy::test_copy_to_new_diagram_transitions_will_be_copied PASSED tests/test_models/test_copy.py::TestDeepCopy::test_copy_to_new_diagram_inner_attr_are_copied PASSED tests/test_models/test_copy.py::TestDeepCopy::test_copy_to_new_diagram_nodes_will_be_copied PASSED tests/test_models/test_copy.</description></item><item><title>Python Project (2) Lint Your Project</title><link>/blog/python-project-2/</link><pubDate>Fri, 23 Apr 2021 00:00:00 +0000</pubDate><guid>/blog/python-project-2/</guid><description>Lint 程式寫出來不難，但是要寫的好看很難很難，在多人協作時就需要一個標準，讓大家可以寫起來差不多，Python 給出了 PEP (Python Enhancement Proposals) 8 Style Guide for Python Code 當然正常人不會去看完，所以有工具幫忙就很重要了，這邊介紹 falke8, black, isort 等，工具，方便統一 Coding Style
Flake8 Flake8 可以檢查專案是否符合 PEP 8 ，然而，該檢查有些過時或是有些規範是相互違反的，這部分就有待團隊自行去規定，此時就需要設定他，Flake8 支援 setup.cfg, tox.ini, 或 .flake8 檔，作為設定，此處為了減少檔案，我們使用上次使用到的 setup.cfg 作為我們的設定檔
Usage 裝好該指令後就可以對你的專案進行檢查
pip3 install flake8 flake8 Max Line Length PEP 8 最常被調整的設定就是其每一行程式碼不可超過的字數，該設定原本為每一行不可以超過 79 字元，其由來是以前的 Terminal 長度為 80 字元，為了不讓他換行，所以建議使用該設定，但是現在螢幕都很寬，所以我們可以與團隊溝通調整最大長度
# setup.cfg [flake8] max-line-length = 88 Exclude 某些檔案可能是由機器自動產生的，你不希望被納入控管，可以使用 exclude 的設定讓他跳過該檔案或目錄，這邊以 Django 的 migration file (機器產生)，以及常見虛擬環境目錄 (他人專案) 作為範例
#setup.cfg [flake8] exclude = */migrations/,env/,venv/ Ignore 在 PEP 8 中不少警告是對立的，如：W503、W504，他們的 Best practice 剛好是對方的 Anti-pattern 團隊們可以選擇對於團隊而言比較好的選項，此時我們就可以忽略該筆檢查</description></item><item><title>Python Project (1) setup.py setup.cfg</title><link>/blog/python-project-1/</link><pubDate>Thu, 22 Apr 2021 00:00:00 +0000</pubDate><guid>/blog/python-project-1/</guid><description>Create Project 開專案一直以來都不是一個簡單的事情，專案開的好可以讓後面的開發更有效率，團隊也可以有比較一致開發準則，接下來幾篇文章會大該說說之前研究開 Python 專案的一些經驗
Create setup.py For Install 如果專案要可以被安裝，就需要寫這檔案，裡面可寫詳述該套件需要裝哪些東西，以及一些資訊，建議放在專案的根目錄，這樣別人就可以直接用你的 Git Repo 去安裝你的套件
from pathlib import Path from setuptools import find_packages, setup REPO_URL = &amp;#34;https://github.com/lambdaTW/python-project&amp;#34; def get_version(rel_path): for line in Path(rel_path).open().read().splitlines(): if line.startswith(&amp;#34;__version__&amp;#34;): delim = &amp;#39;&amp;#34;&amp;#39; if &amp;#39;&amp;#34;&amp;#39; in line else &amp;#34;&amp;#39;&amp;#34; return line.split(delim)[1] raise RuntimeError(&amp;#34;Unable to find version string.&amp;#34;) setup( name=&amp;#34;python-project&amp;#34;, version=get_version(&amp;#34;src/python-project/__init__.py&amp;#34;), description=&amp;#34;My python project&amp;#34;, long_description=Path(&amp;#34;README.md&amp;#34;).open().read(), long_description_content_type=&amp;#34;text/markdown&amp;#34;, python_requires=&amp;#34;&amp;gt;=3.8&amp;#34;, classifiers=[ &amp;#34;Programming Language :: Python :: 3.8&amp;#34;, ], keywords=[&amp;#34;python&amp;#34;, &amp;#34;project&amp;#34;], url=REPO_URL, author=&amp;#34;lambdaTW&amp;#34;, author_email=&amp;#34;lambda@lambda.</description></item><item><title>How to fix no route found error on Django Channels</title><link>/blog/how-to-fix-no-route-found-error-on-django-channels/</link><pubDate>Sat, 25 Jan 2020 00:00:00 +0000</pubDate><guid>/blog/how-to-fix-no-route-found-error-on-django-channels/</guid><description>Issue description Django Channels 對於不存在的路徑存取，全部會拋出錯誤，而不是一般性的警告處理，所以如果和我一樣在 Djangoo Channels 有裝上 Sentry ，而且伺服器在被惡意嘗試路徑時就會看到一堆 ValueError: No route found for path '...'. 的錯誤資訊，好處是知道被打了，壞處就是會噴錢（如果不是自己 Hosting）。
Fix it Make HandleRouteNotFoundMiddleware for this issue from datetime import datetime from logging import getLogger from django.urls.exceptions import Resolver404 logger = getLogger(__file__) class HandleRouteNotFoundMiddleware: def __init__(self, inner): self.inner = inner def __call__(self, scope): try: inner_instance = self.inner(scope) return inner_instance except (Resolver404, ValueError) as e: if &amp;#39;No route found for path&amp;#39; not in str(e) and \ scope[&amp;#34;type&amp;#34;] not in [&amp;#39;http&amp;#39;, &amp;#39;websocket&amp;#39;]: raise e logger.</description></item><item><title>Create a GIN index with Django on AWS RDS</title><link>/blog/create-a-gin-index-with-django-on-aws-rds/</link><pubDate>Fri, 26 Apr 2019 00:00:00 +0000</pubDate><guid>/blog/create-a-gin-index-with-django-on-aws-rds/</guid><description>GIN What is it GIN 是一種 INDEX 可以幫助加速全文搜索的速度
GIN stands for Generalized Inverted Index. GIN is designed for handling cases where the items to be indexed are composite values, and the queries to be handled by the index need to search for element values that appear within the composite items. For example, the items could be documents, and the queries could be searches for documents containing specific words.
Normal SQL 在傳統 SQL 下可以用以下幾個步驟完成建立 GIN INDEX</description></item><item><title>Closure</title><link>/blog/closure/</link><pubDate>Thu, 18 Apr 2019 00:00:00 +0000</pubDate><guid>/blog/closure/</guid><description>Closure What is closure Closure 簡單來說，就是某函數在另一個函數內被創造並且參照了創建函數的某些變數，此時該變數會存留於記憶內，儘管創建函數已經結束。
First time meet to Closure N年前在學習 Common Lisp 時教學內出現了一個陌生又奇特的技巧，Closure，以下是他的實做
(let ((counter 0)) (defun reset () (setf counter 0)) (defun stamp () (setf counter (+ counter 1)))) (list (stamp) (stamp) (reset) (stamp)) ; (1 2 0 1) 為了怕正常人看不懂，以下用 Python 翻譯
def gen_counter(): counter = 0 def reset(): nonlocal counter counter = 0 return counter def stamp(): nonlocal counter counter += 1 return counter return reset, stamp reset, stamp = gen_counter() print(stamp()) # 1 print(stamp()) # 2 print(reset()) # 0 print(stamp()) # 1 可以看出在 gen_counter 內的 兩個函數 (reset, stamp) 一同共用內部變數 counter 儘管 gen_counter 已經回傳並且結束，但是在之後的程式卻還是擁有當初初始化的 count，亦即 counter 在記憶體中不會因為 gen_counter 已經回傳就被回收。</description></item><item><title>gRPC</title><link>/blog/grpc/</link><pubDate>Sun, 18 Nov 2018 00:00:00 +0000</pubDate><guid>/blog/grpc/</guid><description>實做一個可以寄信的 gRPC Proto 寫一個寄發信件服務所需要的資料格式 Proto 是一個文件用來儲存 gRPC server 與 client 交換資料時鎖需要的資料格式，建議可以看看它與 JSON 的對照表來迅速了解需要怎樣寫
syntax = &amp;#34;proto3&amp;#34;; // use proto version 3 package pb; // package name /* Add the Send function for use */ service Mail{ rpc Send (MailRequest) returns (MailStatus) {} } /* Declare what data you need to let server know and server will use it to send a mail */ message MailRequest{ string from = 1; repeated string to = 2; repeated string cc = 3; string subject = 4; string body = 5; string type = 6; } /* Means what the mail status be send or not */ message MailStatus{ int32 status = 1; string code = 2; } 產生 golang 的程式 go get -u github.</description></item><item><title>GolangQuickSort</title><link>/blog/golangquicksort/</link><pubDate>Sun, 05 Aug 2018 00:00:00 +0000</pubDate><guid>/blog/golangquicksort/</guid><description>用 Golang 實做快速排序 (quick sort) 快速排序是很常用的一個排序方法，下方我將會用 Golang 實做同步以及異步的快速排序。
同步 實做 func sort(list []int, center int) (complete []int) { left := []int{} right := []int{} for _, num := range list[:center] { if num &amp;lt;= list[center] { left = append(left, num) } else { right = append(right, num) } } if len(list) &amp;gt; center+1 { for _, num := range list[center+1:] { if num &amp;lt;= list[center] { left = append(left, num) } else { right = append(right, num) } } } if len(left) &amp;gt; 1 { left = sort(left, len(left)/2) } if len(right) &amp;gt; 1 { right = sort(right, len(right)/2) } return append(append(left, list[center]), right.</description></item><item><title>GolangHTTPHandler</title><link>/blog/golanghttphandler/</link><pubDate>Sat, 21 Jul 2018 00:00:00 +0000</pubDate><guid>/blog/golanghttphandler/</guid><description>簡易復刻出的 Golang HTTP HandleFunc 身為一個 web 狗，用新語言寫個 router 也是應該的，Golang 本身在寫 HTTP 服務就有極大的優勢，官方自帶的 library 就很好用了，以至於到目前為止的統計大部分的人還是直接使用原生的 library 而非使用框架，但是 router 這部份就統計看來已經有了大方向， Mux 是目前大多數人使用的 router 框架，這邊我們玩一下 Golang 原生的 handler 讓它可以和原生的 HandleFunc 有一樣的感覺
第一步：寫一個簡單的 HTTP server 相信大家都不會。。。當然就是要 google
關鍵字 ： golang http
第一篇就會看到官方的 library 的連結囉！
開一個新專案 cd $GOPATH/src/ mkdir router touch main.go 依照官方網站的提示寫出一個簡單的 HTTP 服務 package main import ( &amp;#34;fmt&amp;#34; &amp;#34;net/http&amp;#34; &amp;#34;html&amp;#34; &amp;#34;log&amp;#34; ) func main() { http.HandleFunc(&amp;#34;/bar&amp;#34;, func(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, &amp;#34;Hello, %q&amp;#34;, html.</description></item><item><title>FindErrorNumber</title><link>/blog/finderrornumber/</link><pubDate>Thu, 12 Jul 2018 00:00:00 +0000</pubDate><guid>/blog/finderrornumber/</guid><description>找出錯誤的數字，使用 Golang 題目 在輸入一連串的數字中(從一開始連續[1, 2, 3, 4, 5, 6])找到錯誤(重複)的數字，並且把錯誤的先列出來再將正確的數字附加到到後面
輸入 [1,2,2,4] [1,2,2,4,5,5,7] 輸出 [2,3] [2,5,3,6] 實做 main.go package main import &amp;#34;fmt&amp;#34; func findErrorNums(nums []int) (ret []int) { dict := make(map[int]int) for _, num := range nums { _, ok := dict[num] if ok { ret = append(ret, num) } else { dict[num] = num } } for i := 1; i &amp;lt;= len(nums); i++ { _, ok := dict[i] if !</description></item><item><title>Hello Golang</title><link>/blog/helloworld/</link><pubDate>Wed, 04 Jul 2018 00:00:00 +0000</pubDate><guid>/blog/helloworld/</guid><description>Golang 這篇文章將從頭開始說起 Golang 的基本
安裝 Golang 在 archlinux 上面安裝很簡單下以下指令
sudo pacman -S go 設定 Golang 基本環境變數 # super 是我的 使用者名稱 export GOPATH=/home/super/go export GOBIN=/home/super/go/bin export PATH=$PATH:$GOBIN 編輯器 我大部分還是習慣在 emacs 上開發，但是沒在使用 vim 或是 emacs 的人還是建議使用 vscode 比較方便
安裝 vscode curl -O https://aur.archlinux.org/cgit/aur.git/snapshot/visual-studio-code-bin.tar.gz tar -xvz -f visual-studio-code-bin.tar.gz cd visual-studio-code-bin makepkg -sir . 設定 Golang 按下安裝 vscode 建議的 extension (選擇 install)
重新載入 vscode (選擇 reload)
寫下你的第一支程式 進入你的家目錄中的 go/src 資料夾 裡面建立你的第一支程式的目錄 hello mkdir -p ~/go/src/hello cd ~/go/src/hello 用 vscode 打開 code main.</description></item></channel></rss>